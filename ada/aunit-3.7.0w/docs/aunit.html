<html lang="en">
<head>
<title>AUnit Cookbook</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="AUnit Cookbook">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
pre.smallexample {background-color:rgb(240,240,240);
                     font-family: courier new,courier,fixed;
                     font-size: 14px;
                     margin: 0px 40px 0px 40px;
                     border-width: 1px 2px 2px 1px;
                     border-top-style: dotted;
                     border-left-style: dotted;
                     border-right-style: solid;
                     border-bottom-style: solid;
                     border-color: black;}
   code             {color:black;
                     font-family: courier new,courier,fixed;
                     font-size: 14px;}
   body             {font-family: arial,helvetica,sans-serif;
                     font-size: 16px;
                     width: 800px;
                     text-align: justify}
   samp             {font-family: courier new,courier,fixed;
                     font-size: 14px}

--></style>
</head>
<body>
<h1 class="settitle">AUnit Cookbook</h1>
<font size="+2">
<p><font color="#33ff33">A</font><font color="#cc0000">U</font>nit Cookbook
<p>AUnit - version 3.7.0w
<p>Configuration level $Revision: 302445 $
<p>Date: 10 April 2014
<p>AdaCore
</font>

   <p><font size="+1">
<p><a href="http://www.adacore.com">http://www.adacore.com</a>
</font>

   <p><p>Copyright &copy; 2000-2013, AdaCore

   <p><p>This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">AUnit</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#Overview">Overview</a>
<li><a accesskey="3" href="#Test-Cases">Test Cases</a>
<li><a accesskey="4" href="#Fixture">Fixture</a>
<li><a accesskey="5" href="#Suite">Suite</a>
<li><a accesskey="6" href="#Reporting">Reporting</a>
<li><a accesskey="7" href="#Test-Organization">Test Organization</a>
<li><a accesskey="8" href="#Using-AUnit-with-Restricted-Run_002dTime-Libraries">Using AUnit with Restricted Run-Time Libraries</a>
<li><a accesskey="9" href="#Installation-and-Use">Installation and Use</a>
<li><a href="#GPS-Support">GPS Support</a>
</ul>

<!-- ====================================================================== -->
<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Overview">Overview</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p class="noindent">This is a short guide for using the AUnit test framework. 
AUnit is an adaptation of the Java JUnit (Kent Beck, Erich Gamma) and C++
CppUnit (M. Feathers, J. Lacoste, E. Sommerlade, B. Lepilleur, B. Bakker,
S. Robbins) unit test frameworks for Ada code.

<!--  -->
<h3 class="section">1.1 What's new in AUnit 3</h3>

<p>AUnit 3 brings several enhancements over AUnit 2 and AUnit 1:
     <ul>
<li>Removal of the genericity of the AUnit framework, making the AUnit 3
API as close as possible to AUnit 1.

     <li>Emulates dynamic memory management for limited run-time profiles.

     <li>Provides a new XML reporter, and changes harness invocation to support
easy switching among text, XML and customized reporters.

     <li>Provides new tagged types Simple_Test_Case, Test_Fixture and
Test_Caller that correspond to CppUnit's TestCase, TestFixture and TestCaller
classes.

     <li>Emulates exception propagation for restricted run-time profiles
(e.g. ZFP), by using the  gcc builtin setjmp/longjmp mechanism.

     <li>Reports the source location of an error when possible.

   </ul>

<!--  -->
<h3 class="section">1.2 Examples</h3>

<p>With this version, we have provided new examples illustrating the enhanced
features of the framework. These examples are in the AUnit
installation directory:
&lt;aunit-root&gt;/share/examples/aunit, and are also available in the source
distribution aunit-3.7.0w-src/examples.

   <p>The following examples are provided:
     <ul>
<li>simple_test: shows use of AUnit.Simple_Test_Cases
(see <a href="#AUnit_002eSimple_005fTest_005fCases">AUnit.Simple_Test_Cases</a>). 
<li>test_caller: shows use of AUnit.Test_Caller (see <a href="#AUnit_002eTest_005fCaller">AUnit.Test_Caller</a>). 
<li>test_fixture: example of a test fixture (see <a href="#Fixture">Fixture</a>). 
<li>liskov: This suite tests conformance to the Liskov Substitution Principle
of a pair of simple tagged types. (see <a href="#OOP-considerations">OOP considerations</a>)
<li>failures: example of handling and reporting failed tests
(see <a href="#Reporting">Reporting</a>). 
<li>calculator: a full example of test suite organization. 
</ul>

<!--  -->
<h3 class="section">1.3 Note about limited run-times</h3>

<p>AUnit allows a great deal of flexibility as to the structure of test cases,
suites and harnesses.  The templates and examples given in this document
illustrate how to use AUnit while staying within the constraints of the
GNAT Pro restricted and Zero Foot Print (ZFP) run-time libraries. Therefore,
they avoid the use of dynamic allocation and some other features that would
be outside of the profiles corresponding to these libraries. Tests targeted
to the full Ada run-time library need not comply with these constraints.

<!--  -->
<h3 class="section">1.4 Thanks</h3>

<p>This document is adapted from the JUnit and CppUnit Cookbooks documents
contained in their respective release packages.

   <p>Special thanks to Francois Brun of Thales Avionics for his ideas about
support for OOP testing.

<!-- ====================================================================== -->
<div class="node">
<a name="Overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Cases">Test Cases</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Overview</h2>

<p>How do you write testing code?

   <p>The simplest way is as an expression in a debugger. You can change
debug expressions without recompiling, and you can wait to decide
what to write until you have seen the running objects. You can also
write test expressions as statements that print to the standard
output stream. Both styles of tests are limited because they require
human judgment to analyze their results. Also, they don't compose
nicely - you can only execute one debug expression at a time and a
program with too many print statements causes the dreaded "Scroll
Blindness".

   <p>AUnit tests do not require human judgment to interpret, and it is
easy to run many of them at the same time. When you need to test
something, here is what you do:

     <ol type=1 start=1>

     <li>Derive a test case type from <code>AUnit.Simple_Test_Cases.Test_Case</code>.

     <p>Several test case types are available:
          <ul>
<li><code>AUnit.Simple_Test_Cases.Test_Case</code>: the base type for all test
cases. Needs overriding of <code>Name</code> and <code>Run_Test</code>. 
<li><code>AUnit.Test_Cases.Test_Case</code>: the traditional AUnit test case type,
allowing multiple test routines registration, each being run and reported
independently. 
<li><code>AUnit.Test_Fixtures.Test_Fixture</code>: used together with
<code>AUnit.Test_Caller</code>, this allows easy creation of test suites comprising
several test cases that share the same fixture (see <a href="#Fixture">Fixture</a>). 
</ul>

     <p>See <a href="#Test-Cases">Test Cases</a>, for simple examples of use of these types.

     <li>When you want to check a value<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>, use one of the
following <code>Assert</code><a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a> methods:

     <pre class="smallexample">          AUnit.Assertions.Assert (<b>Boolean_Expression</b>, <b>String_Description</b>);
</pre>
     <p>or:
     <pre class="smallexample">          if not AUnit.Assertions.Assert (<b>Boolean_Expression</b>, <b>String_Description</b>) then
             return;
          end if;
</pre>
     <p>If you need to test that a method raises an expected exception, there
is the procedure <code>Assert_Exception</code> that takes an access value designating the procedure
to be tested as a parameter:

     <pre class="smallexample">          type Throwing_Exception_Proc is access procedure;
          
             procedure Assert_Exception
               (Proc    : Throwing_Exception_Proc;
                Message : String;
                Source  : String := GNAT.Source_Info.File;
                Line    : Natural := GNAT.Source_Info.Line);
             --  Test that Proc throws an exception and record "Message" if not.
</pre>
     <p>Example:

     <pre class="smallexample">          -- Declared at library level:
             procedure Test_Raising_Exception is
             begin
                call_to_the_tested_method (some_args);
             end Test_Raising_Exception;
          
          -- In test routine:
          procedure My_Routine (...) is
          begin
             Assert_Exception (Test_Raising_Exception'Access, <b>String_Description</b>);
          end;
</pre>
     <p>This procedure can handle exceptions with all run-time profiles (including
zfp).  If you are using a run-time library capable of propagating exceptions,
you can use the following idiom instead:

     <pre class="smallexample">          procedure My_Routine (...) is
             begin
                ...
                -- Call subprogram expected to raise an exception:
                Call_To_The_Tested_Method (some_args);
                Assert (False, ``exception not raised'');
             exception
                when desired_exception =&gt;
                   null;
             end My_Procedure;
</pre>
     <p>An unexpected exception will be recorded as such by the framework.  If you want
your test routine to continue beyond verifying that an expected exception has
been raised, you can nest the call and handler in a block.

     <li>Create a suite function inside a package to gather together test cases
and sub-suites<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>.

     <li>At any level at which you wish to run tests, create a harness by
instantiating procedure <code>AUnit.Run.Test_Runner</code> or function
<code>AUnit.Run.Test_Runner_With_Status</code> with the top-level suite
function to be executed. This instantiation provides a routine
that executes all of the tests in the suite. We will call this
user-instantiated routine <b>Run</b> in the text for backward compatibility
to tests developed for AUnit 1. Note that only one instance of <b>Run</b>
can execute at a time.  This is a tradeoff made to reduce the stack requirement
of the framework by allocating test result reporting data structures
statically.

     <p>It is possible to pass a filter to a <code>Test_Runner</code>, so that only a
subset of the tests run. In particular, this filter could be initialized from
a command line parameter. See the package <code>AUnit.Test_Filters</code> for an
example of such a filter. AUnit does not automatically initialize this filter
from the command line both because it would not be supported with some of the
limited runtimes (zero footprint for instance), and because you might want to
pass the argument through different ways (as a parameter to switch, or a stand-alone
command line argument for instance).

     <p>It is also possible to control the contents of the output report by passing an
object of type <code>AUnit_Options</code> to the <code>Test_Runner</code>. See package
<code>AUnit.Options</code> for details.

     <li>Build the code that calls the harness <b>Run</b> routine using
gnatmake or gprbuild. The GNAT project file <i>aunit.gpr</i> contains all
necessary switches, and should be imported into your root project file.

        </ol>

<!-- ====================================================================== -->
<div class="node">
<a name="Test-Cases"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Fixture">Fixture</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview">Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Test Case</h2>

<ul class="menu">
<li><a accesskey="1" href="#AUnit_002eSimple_005fTest_005fCases">AUnit.Simple_Test_Cases</a>
<li><a accesskey="2" href="#AUnit_002eTest_005fCases">AUnit.Test_Cases</a>
<li><a accesskey="3" href="#AUnit_002eTest_005fCaller">AUnit.Test_Caller</a>
</ul>

<p class="noindent">In this chapter, we will introduce how to use the various forms of Test
Cases. We will illustrate with a very simple test routine, that verifies
that the sum of two Moneys with the same currency result in a value
which is the sum of the values of the two Moneys:

<pre class="smallexample">     declare
         X, Y: Some_Currency;
     begin
        X := 12; Y := 14;
        Assert (X + Y = 26, "Addition is incorrect");
     end;
</pre>
   <p>The following sections will show how to use this test method using the
different test case types available in AUnit.

<!--  -->
<div class="node">
<a name="AUnit.Simple_Test_Cases"></a>
<a name="AUnit_002eSimple_005fTest_005fCases"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#AUnit_002eTest_005fCases">AUnit.Test_Cases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Cases">Test Cases</a>

</div>

<h3 class="section">3.1 AUnit.Simple_Test_Cases</h3>

<p class="noindent"><code>AUnit.Simple_Test_Cases.Test_Case</code> is the root type of all test
 cases. Although generally not meant to be used directly, it provides a
 simple and quick way to run a test.

   <p>This tagged type has several methods that need to be defined, or may be
overridden.

     <ul>
<li><code>function Name (T : Test_Case) return Message_String is abstract</code>:

     <p>This function returns the Test name. You can easily translate regular
strings to Message_String using <code>AUnit.Format</code>. For example:

     <pre class="smallexample">          function Name (<b>T</b> : <b>Money_Test</b>) return Message_String is
          begin
             return Format (<b>"Money Tests"</b>);
          end Name;
</pre>
     <li><code>procedure Run_Test (T : in out Test_Case) is abstract</code>:

     <p>This procedure contains the test code. For example:
     <pre class="smallexample">          procedure Run_Test (<b>T</b> : in out <b>Money_Test</b>) is
              <b>X, Y: Some_Currency;</b>
          begin
             <b>X := 12; Y := 14;</b>
             <b>Assert (X + Y = 26, "Addition is incorrect");</b>
          end Run_Test;
</pre>
     <li><code>procedure Set_Up (T : in out Test_Case);</code> and <code>procedure
Tear_Down (T : in out Test_Case);</code> (default implementations do nothing):

     <p>These procedures are meant to respectively set up or tear down the
environment before running the test case. See <a href="#Fixture">Fixture</a>, for examples
of how to use these methods.

   </ul>

   <p>You can find a compilable example of
<code>AUnit.Simple_Test_Cases.Test_Case</code> usage in your AUnit installation
directory: &lt;aunit-root&gt;/share/examples/aunit/simple_test/ or from the
source distribution aunit-3.7.0w-src/examples/simple_test/

<!--  -->
<div class="node">
<a name="AUnit.Test_Cases"></a>
<a name="AUnit_002eTest_005fCases"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#AUnit_002eTest_005fCaller">AUnit.Test_Caller</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#AUnit_002eSimple_005fTest_005fCases">AUnit.Simple_Test_Cases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Cases">Test Cases</a>

</div>

<h3 class="section">3.2 AUnit.Test_Cases</h3>

<p><code>AUnit.Test_Cases.Test_Case</code> is derived from
<code>AUnit.Simple_Test_Cases.Test_Case</code> and defines its
<code>Run_Test</code> procedure.

   <p>It allows a very flexible composition of Test routines inside a single
test case, each being reported independently.

   <p>The following subprograms must be considered for inheritance, overriding or
completion:

     <ul>
<li><code>function Name (T : Test_Case) return Message_String is abstract;</code>
Inherited. See <a href="#AUnit_002eSimple_005fTest_005fCases">AUnit.Simple_Test_Cases</a>.

     <li><code>procedure Set_Up (T : in out Test_Case)</code> and <code>procedure
Tear_Down (T : in out Test_Case)</code>
Inherited. See <a href="#AUnit_002eSimple_005fTest_005fCases">AUnit.Simple_Test_Cases</a>.

     <li><code>procedure Set_Up_Case (T : in out Test_Case)</code> and
<code>procedure Tear_Down_Case (T : in out Test_Case)</code>
Default implementation does nothing.

     <p>The latter procedures provide an opportunity to Set Up and Tear Down the test
case before and after all test routines have been executed. In contrast, the
inherited <code>Set_Up</code> and <code>Tear_Down</code> are called before and after the
execution of each individual test routine.

     <li><code>procedure Register_Tests (T : in out Test_Case) is
abstract</code>
This procedure must be overridden. It is responsible for registering all
the test routines that will be run. You need to use either
<code>Registration.Register_Routine</code> or the generic
<code>Specific_Test_Case.Register_Wrapper</code> methods defined in
<code>AUnit.Test_Cases</code> to register a routine. A test routine has the
form:
     <pre class="smallexample">          procedure Test_Routine (T : in out Test_Case'Class);
</pre>
     <p>or
     <pre class="smallexample">          procedure Test_Wrapper (T : in out Specific_Test_Case'Class);
</pre>
     <p>The former procedure is used mainly for dispatching calls
(see <a href="#OOP-considerations">OOP considerations</a>).

   </ul>

   <p>Using this type to test our money addition, the package spec is:

<pre class="smallexample">     with AUnit; use AUnit;
     with AUnit.Test_Cases; use AUnit.Test_Cases;
     
     package <b>Money_Tests</b> is
     
        type <b>Money_Test</b> is new Test_Cases.Test_Case with <b>null record</b>;
     
        procedure Register_Tests (<b>T</b>: in out <b>Money_Test</b>);
        -- Register routines to be run
     
        function Name (<b>T</b>: <b>Money_Test</b>) return Message_String;
        -- Provide name identifying the test case
     
        -- Test Routines:
        procedure <b>Test_Simple_Add</b> (<b>T</b> : in out Test_Cases.Test_Case'Class);
     end <b>Money_Tests</b>;
</pre>
   <p>The package body is:

<pre class="smallexample">     with AUnit.Assertions; use AUnit.Assertions;
     
     package body <b>Money_Tests</b> is
     
        procedure <b>Test_Simple_Add</b> (<b>T</b> : in out Test_Cases.Test_Case'Class) is
           <b>X, Y : Some_Currency;</b>
        begin
           <b>X := 12; Y := 14;</b>
           <b>Assert (X + Y = 26, "Addition is incorrect");</b>
        end <b>Test_Simple_Add</b>;
     
        -- Register test routines to call
        procedure Register_Tests (<b>T</b>: in out <b>Money_Test</b>) is
     
           use AUnit.Test_Cases.Registration;
     
        begin
           -- Repeat for each test routine:
           Register_Routine (<b>T</b>, <b>Test_Simple_Add</b>'Access, <b>"Test Addition"</b>);
        end Register_Tests;
     
        -- Identifier of test case
     
        function Name (<b>T</b>: <b>Money_Test</b>) return Test_String is
        begin
           return Format (<b>"Money Tests"</b>);
        end Name;
     
     end <b>Money_Tests</b>;
</pre>
   <!--  -->
<div class="node">
<a name="AUnit.Test_Caller"></a>
<a name="AUnit_002eTest_005fCaller"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#AUnit_002eTest_005fCases">AUnit.Test_Cases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Cases">Test Cases</a>

</div>

<h3 class="section">3.3 AUnit.Test_Caller</h3>

<p class="noindent"><code>Test_Caller</code> is a generic package that is used with
<code>AUnit.Test_Fixtures.Test_Fixture</code>. <code>Test_Fixture</code> is a very
simple type that provides only the <code>Set_Up</code> and <code>Tear_Down</code>
procedures. This type is meant to contain a set of user-defined test
routines, all using the same Set up and Tear down mechanisms. Once those
routines are defined, the Test_Caller package is used to incorporate them
directly into a test suite.

   <p>With our money example, the Test_Fixture is:

<pre class="smallexample">     with AUnit.Test_Fixtures;
     package <b>Money_Tests</b> is
        type <b>Money_Test</b> is new AUnit.Test_Fixtures.Test_Fixture <b>with null record</b>;
     
        procedure <b>Test_Simple_Add</b> (<b>T</b> : in out <b>Money_Test</b>);
     
     end <b>Money_Tests</b>;
</pre>
   <p>The test suite (see <a href="#Suite">Suite</a>) calling the test cases created from
this Test_Fixture is:

<pre class="smallexample">     with AUnit.Test_Suites;
     
     package Money_Suite is
        function Suite return AUnit.Test_Suites.Access_Test_Suite;
     end Money_Suite;
</pre>
   <p>With the corresponding body:

<pre class="smallexample">     with AUnit.Test_Caller;
     with Money_Tests;
     
     package body Money_Suite is
     
        package Money_Caller is new AUnit.Test_Caller
          (Money_Tests.Money_Test);
     
        function Suite return Aunit.Test_Suites.Access_Test_Suite is
           Ret : AUnit.Test_Suites.Access_Test_Suite :=
                   AUnit.Test_Suites.New_Suite;
        begin
           Ret.Add_Test
             (Money_Caller.Create
                (<b>"Money Test : Test Addition"</b>,
                 <b>Money_Tests.Test_Simple_Add</b>'Access));
           return Ret;
        end Suite;
     
     end Money_Suite;
</pre>
   <p>Note that <code>New_Suite</code> and <code>Create</code> are fully compatible with
limited run-times (in particular, those without dynamic allocation support). 
Note, however, that for non-native run-time libraries, you cannot extend
<code>Test_Fixture</code> with a controlled component.

   <p>You can find a compilable example of
<code>AUnit.Test_Caller</code> use in the AUnit installation
directory: &lt;aunit-root&gt;/share/examples/aunit/test_caller/ or from the
source distribution aunit-3.7.0w-src/examples/test_caller/

<!-- ====================================================================== -->
<div class="node">
<a name="Fixture"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Suite">Suite</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Cases">Test Cases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Fixture</h2>

<p class="noindent">Tests need to run against the background of a set of known entities. 
This set is called a test fixture. When you are
writing tests you will often find that you spend more time writing
code to set up the fixture than you do in actually testing values.

   <p>You can make writing fixture code easier by sharing it. 
Often you will be able to use the same fixture for several different
tests. Each case will send slightly different messages or parameters to the
fixture and will check for different results.

   <p>When you have a common fixture, here is what you do:

     <ol type=1 start=1>
<li>Create a Test Case package as in previous section.

     <li>Declare variables or components for elements of the fixture either
as part of the test case type or in the package body.

     <li>According to the Test_Case type used, override its <code>Set_Up</code>
and/or <code>Set_Up_Case</code> method:

          <ul>
<li><code>AUnit.Simple_Test_Cases</code>: <code>Set_Up</code> is called before
<code>Run_Test</code>.

          <li><code>AUnit.Test_Cases</code>: <code>Set_Up</code> is called before each test
routine while <code>Set_Up_Case</code> is called once before the routines are run.

          <li><code>AUnit.Test_Fixture</code>: <code>Set_Up</code> is called before each
test case created using <code>Aunit.Test_Caller</code>. 
</ul>

     <li>You can also override <code>Tear_Down</code> and/or
<code>Tear_Down_Case</code> that are executed after the test is run.

        </ol>

<p class="noindent">For example, to write several test cases that want to work with
different combinations of 12 Euros, 14 Euros, and 26 US Dollars, first
create a fixture. The package spec is now:

<pre class="smallexample">     with <b>AUnit</b>; use <b>AUnit</b>;
     
     package <b>Money_Tests</b> is
        use Test_Results;
     
        type <b>Money_Test</b> is new Test_Cases.Test_Case with <b>null record</b>;
     
        procedure Register_Tests (<b>T</b>: in out <b>Money_Test</b>);
        -- Register routines to be run
     
        function Name (<b>T</b> : <b>Money_Test</b>) return Test_String;
        -- Provide name identifying the test case
     
        procedure Set_Up (<b>T</b> : in out <b>Money_Test</b>);
        --  Set up performed before each test routine
     
        -- Test Routines:
        procedure <b>Test_Simple_Add</b> (<b>T</b> : in out Test_Cases.Test_Case'Class);
     end <b>Money_Tests</b>;
</pre>
   <p>The body becomes:

<pre class="smallexample">     package body <b>Money_Tests</b> is
     
        use Assertions;
     
        -- Fixture elements
     
        <b>EU_12, EU_14 : Euro;
        US_26        : US_Dollar;</b>
     
        -- Preparation performed before each routine
     
        procedure Set_Up (<b>T</b>: in out <b>Money_Test</b>) is
        begin
           <b>EU_12 := 12; EU_14 := 14;
           US_26 := 26;</b>
        end Set_Up;
     
        procedure <b>Test_Simple_Add</b> (<b>T</b> : in out Test_Cases.Test_Case'Class) is
            <b>X, Y : Some_Currency;</b>
        begin
            <b>Assert
              (EU_12 + EU_14 /= US_26,
               "US and EU currencies not differentiated");</b>
        end <b>Test_Simple_Add</b>;
     
        -- Register test routines to call
        procedure Register_Tests (<b>T</b>: in out <b>Money_Test</b>) is
     
           use <b>Test_Cases.Registration</b>;
     
        begin
           -- Repeat for each test routine:
           Register_Routine (<b>T</b>, <b>Test_Simple_Add</b>'Access, <b>"Test Addition"</b>);
        end Register_Tests;
     
        -- Identifier of test case
        function Name (<b>T</b>: <b>Money_Test</b>) return Test_String is
        begin
           return Format (<b>"Money Tests"</b>);
        end Name;
     
     end <b>Money_Tests</b>;
</pre>
   <p class="noindent">Once you have the fixture in place, you can write as many test
routines as you like. Calls to <code>Set_Up</code> and <code>Tear_Down</code>
bracket the invocation of each test routine.

   <p>Once you have several test cases, organize them into a Suite.

   <p>You can find a compilable example of fixture set up using
<code>AUnit.Test_Fixture</code> in your AUnit installation
directory: &lt;aunit-root&gt;/share/examples/aunit/test_fixture/ or from the
AUnit source distribution aunit-3.7.0w-src/examples/test_fixture/.

<!-- ====================================================================== -->
<div class="node">
<a name="Suite"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reporting">Reporting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fixture">Fixture</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Suite</h2>

<!--  -->
<h3 class="section">5.1 Creating a Test Suite</h3>

<p>How do you run several test cases at once?

   <p>As soon as you have two tests, you'll want to run them together. 
You could run the tests one at a time yourself, but you would quickly
grow tired of that. Instead, AUnit provides an object, <code>Test_Suite</code>,
that runs any number of test cases together.

<p class="noindent">To create a suite of two test cases and run them together, first create
a test suite:

<pre class="smallexample">     with AUnit.Test_Suites;
     package <b>My_Suite</b> is
        function <b>Suite</b> return AUnit.Test_Suites.Access_Test_Suite;
     end <b>My_Suite</b>;
</pre>
   <pre class="smallexample">     --  Import tests and sub-suites to run
     with <b>Test_Case_1, Test_Case_2</b>;
     
     package body <b>My_Suite</b> is
        use AUnit.Test_Suites;
     
        -- Statically allocate test suite:
        <b>Result</b> : aliased Test_Suite;
     
        --  Statically allocate test cases:
        <b>Test_1 : aliased Test_Case_1.Test_Case;</b>
        <b>Test_2 : aliased Test_Case_2.Test_Case;</b>
     
        function <b>Suite</b> return Access_Test_Suite is
        begin
           Add_Test (<b>Result'Access, Test_Case_1'Access</b>);
           Add_Test (<b>Result'Access, Test_Case_2'Access</b>);
           return <b>Result'Access</b>;
        end <b>Suite</b>;
     end <b>My_Suite</b>;
</pre>
   <p>Instead of statically allocating test cases and suites,
you can also use <code>AUnit.Test_Suites.New_Suite</code> and/or
<code>AUnit.Memory.Utils.Gen_Alloc</code>. These routines emulate dynamic
memory management (see <a href="#Using-AUnit-with-Restricted-Run_002dTime-Libraries">Using AUnit with Restricted Run-Time Libraries</a>). 
Similarly, if you know that the tests will always be executed for a run-time
profile that supports dynamic memory management, you can allocate these
objects directly with the Ada <code>"new"</code> operator.

<p class="noindent">The harness is:
<pre class="smallexample">     with <b>My_Suite</b>;
     with AUnit.Run;
     with AUnit.Reporter.Text;
     
     procedure <b>My_Tests</b> is
       procedure <b>Run</b> is new AUnit.Run.Test_Runner (<b>My_Suite.Suite</b>);
       Reporter : AUnit.Reporter.Text.Text_Reporter;
     begin
        <b>Run</b> (Reporter);
     end <b>My_Tests</b>;
</pre>
   <!--  -->
<h3 class="section">5.2 Composition of Suites</h3>

<p class="noindent">Typically, one will want the flexibility to execute a complete set
of tests, or some subset of them. In order to facilitate this, we can
compose both suites and test cases, and provide a harness for any given
suite:

<pre class="smallexample">     -- Composition package:
     with <b>AUnit</b>; use <b>AUnit</b>;
     package <b>Composite_Suite</b> is
        function <b>Suite</b> return Test_Suites.Access_Test_Suite;
     end <b>Composite_Suite</b>;
     
     --  Import tests and suites to run
     with <b>This_Suite, That_Suite</b>;
     with AUnit.Tests;
     
     package body <b>Composite_Suite</b> is
        use Test_Suites;
     
        --  Here we dynamically allocate the suite using the New_Suite function
        --  We use the 'Suite' functions provided in This_Suite and That_Suite
        --  We also use Ada 2005 distinguished receiver notation to call Add_Test
     
        function <b>Suite</b> return Access_Test_Suite is
           <b>Result</b> : Access_Test_Suite := AUnit.Test_Suites.New_Suite;
        begin
           <b>Result</b>.Add_Test (<b>This_Suite.Suite</b>);
           <b>Result</b>.Add_Test (<b>That_Suite.Suite</b>);
           return <b>Result</b>;
        end <b>Suite</b>;
     end <b>Composite_Suite</b>;
</pre>
   <p class="noindent">The harness remains the same:

<pre class="smallexample">     with <b>Composite_Suite</b>;
     with AUnit.Run;
     
     procedure <b>My_Tests</b> is
       procedure <b>Run</b> is new AUnit.Run.Test_Runner (<b>Composite_Suite.Suite</b>);
       Reporter : AUnit.Reporter.Text.Text_Reporter;
     begin
        <b>Run</b> (Reporter);
     end <b>My_Tests</b>;
</pre>
   <p class="noindent">As can be seen, this is a very flexible way of composing test cases
into execution runs: any combination of test cases and sub-suites can
be collected into a suite.

<!-- ====================================================================== -->
<div class="node">
<a name="Reporting"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Organization">Test Organization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Suite">Suite</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Reporting</h2>

<p>Test results can be reported using several 'Reporters'. By default, two
reporters are available in AUnit:
<code>AUnit.Reporter.Text.Text_Reporter</code> and
<code>AUnit.Reporter.XML.XML_Reporter</code>. The first one is a simple
console reporting routine, while the second one outputs the result using
an XML format. These are invoked when the <code>Run</code> routine of an
instantiation of <code>AUnit.Run.Test_Runner</code> is called.

<p class="noindent">New reporters can be created using children of
<code>AUnit.Reporter.Reporter</code>.

<p class="noindent">The Reporter is selected by specifying it when calling <b>Run</b>:

<pre class="smallexample">     with A_Suite;
     with AUnit.Run;
     <b>with AUnit.Reporter.Text;</b>
     
     procedure My_Tests is
       procedure Run is new AUnit.Run.Test_Runner (A_Suite.Suite);
       <b>Reporter : AUnit.Reporter.Text.Text_Reporter;</b>
     begin
        Run (<b>Reporter</b>);
     end My_Tests;
</pre>
   <p>The final report is output once all tests have been run, so that they can be
grouped depending on their status (passed or fail). If you need to output the
tests as they are run, you should consider extending the <code>Test_Result</code>
type and do some output every time a success or failure is registered.

<h3 class="section">6.1 Text output</h3>

<p>Here is an example where the test harness runs 4 tests, one reporting an
assertion failure, one reporting an unexpected error (exception):

<pre class="smallexample">     --------------------
     
        Total Tests Run: 4
     
        Successful Tests: 2
           Test addition
           Test subtraction
     
        Failed Assertions: 1
     
           Test addition (failure expected)
                 Test should fail this assertion, as 5+3 /= 9
                 at math-test.adb:29
     
     
        Unexpected Errors: 1
     
           Test addition (error expected)
                 CONSTRAINT_ERROR
     
     
     
     Time: 2.902E-4 seconds
</pre>
   <p><a name="index-colors-1"></a>This reporter can optionally use colors (green to report success, red to report
errors). Since not all consoles support it, this is off by default, but you can
call <code>Set_Use_ANSI_Colors</code> to activate support for colors.

<h3 class="section">6.2 XML output</h3>

<p>Following is the same harness run using XML output. The XML format used
matches the one used by CppUnit.

   <p>Note that text set in the Assert methods, or as test case names should
be compatible with utf-8 character encoding, or the XML will not be
correctly formatted.

<pre class="smallexample">     &lt;?xml version='1.0' encoding='utf-8' ?&gt;
     &lt;TestRun elapsed='1.107E-4'&gt;
       &lt;Statistics&gt;
         &lt;Tests&gt;4&lt;/Tests&gt;
         &lt;FailuresTotal&gt;2&lt;/FailuresTotal&gt;
         &lt;Failures&gt;1&lt;/Failures&gt;
         &lt;Errors&gt;1&lt;/Errors&gt;
       &lt;/Statistics&gt;
       &lt;SuccessfulTests&gt;
         &lt;Test&gt;
           &lt;Name&gt;Test addition&lt;/Name&gt;
         &lt;/Test&gt;
         &lt;Test&gt;
           &lt;Name&gt;Test subtraction&lt;/Name&gt;
         &lt;/Test&gt;
       &lt;/SuccessfulTests&gt;
       &lt;FailedTests&gt;
         &lt;Test&gt;
           &lt;Name&gt;Test addition (failure expected)&lt;/Name&gt;
           &lt;FailureType&gt;Assertion&lt;/FailureType&gt;
           &lt;Message&gt;Test should fail this assertion, as 5+3 /= 9&lt;/Message&gt;
           &lt;Location&gt;
             &lt;File&gt;math-test.adb&lt;/File&gt;
             &lt;Line&gt;29&lt;/Line&gt;
           &lt;/Location&gt;
         &lt;/Test&gt;
         &lt;Test&gt;
           &lt;Name&gt;Test addition (error expected)&lt;/Name&gt;
           &lt;FailureType&gt;Error&lt;/FailureType&gt;
           &lt;Message&gt;CONSTRAINT_ERROR&lt;/Message&gt;
         &lt;/Test&gt;
       &lt;/FailedTests&gt;
     &lt;/TestRun&gt;
</pre>
   <!-- ====================================================================== -->
<div class="node">
<a name="Test-Organization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-AUnit-with-Restricted-Run_002dTime-Libraries">Using AUnit with Restricted Run-Time Libraries</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reporting">Reporting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Test Organization</h2>

<ul class="menu">
<li><a accesskey="1" href="#General-considerations">General considerations</a>
<li><a accesskey="2" href="#OOP-considerations">OOP considerations</a>
<li><a accesskey="3" href="#Testing-generic-units">Testing generic units</a>
</ul>

<!--  -->
<div class="node">
<a name="General-considerations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#OOP-considerations">OOP considerations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Organization">Test Organization</a>

</div>

<h3 class="section">7.1 General considerations</h3>

<p>This section will discuss an approach to organizing an AUnit test harness,
considering some possibilities offered by Ada language features.

   <p>The general idea behind this approach to test organization is that making the
test case a child of the unit under test gives some useful facilities. 
The test case gains visibility to the private part of the unit under test. 
This offers a more &ldquo;white box&rdquo; approach to examining the state of the unit
under test than would, for instance, accessor functions defined in a separate
fixture that is a child of the unit under test. Making the test case a child of
the unit under test also provides a way to make the test case share certain
characteristics of the unit under test.  For instance, if the unit under test
is generic, then any child package (here the test case) must be also generic:
any instantiation of the parent package will require an instantiation of the
test case in order to accomplish its aims.

   <p>Another useful concept is matching the test case type to that of the unit
under test:

     <ul>
<li>When testing a generic package, the test package should also be
generic. 
<li>When testing a tagged type, then test routines should be
dispatching, and the test case type for a derived tagged type should be a
derivation of the test case type for the parent. 
<li>etc. 
</ul>

   <p>Maintaining such similarity of properties between the test case and unit under
test can facilitate the testing of units derived in various ways.

   <p>The following sections will concentrate on applying these concepts to
the testing of tagged type hierarchies and to the testing of generic units.

   <p>A full example of this kind of test organization is available in the AUnit
installation directory: &lt;AUnit-root&gt;/share/examples/aunit/calculator, or
from the AUnit source distribution
aunit-3.7.0w-src/examples/calculator.

<!--  -->
<div class="node">
<a name="OOP-considerations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Testing-generic-units">Testing generic units</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#General-considerations">General considerations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Organization">Test Organization</a>

</div>

<h3 class="section">7.2 OOP considerations</h3>

<p>When testing a hierarchy of tagged types, one will often want to run tests
for parent types against their derivations without rewriting those tests.

   <p>We will illustrate some of the possible solutions available in AUnit,
using the following simple example that we want to test:

   <p>First we consider a <code>Root</code> package defining the <code>Parent</code>
tagged type, with two procedures P1 and P2.

<pre class="smallexample">     package Root is
        type Parent is tagged private;
     
        procedure P1 (P : in out Parent);
        procedure P2 (P : in out Parent);
     private
        type Parent is tagged record
           Some_Value : Some_Type;
        end record;
     end Root;
</pre>
   <p>We will also consider a derivation of type <code>Parent</code>:

<pre class="smallexample">     with Root;
     package Branch is
        type Child is new Root.Parent with private;
     
        procedure P2 (C : in out Child);
        procedure P3 (C : in out Child);
     private
        type Child is new Root.Parent with null record;
     end Branch;
</pre>
   <p class="noindent">Note that <code>Child</code> retains the parent implementation of <code>P1</code>,
overrides <code>P2</code> and adds <code>P3</code>. Its test will override
<code>Test_P2</code> when we override <code>P2</code> (not necessary, but certainly
possible).

<h4 class="subsection">7.2.1 Using AUnit.Test_Fixtures</h4>

<p class="noindent">Using <code>Test_Fixture</code> type, we first test <code>Parent</code> using the
following test case:
<pre class="smallexample">     with AUnit; use AUnit;
     with AUnit.Test_Fixtures; use AUnit.Test_Fixtures;
     
     --  We make this package a child package of Parent so that it can have
     --  visibility to its private part
     package <b>Root.Tests</b> is
     
        type <b>Parent_Access</b> is access all <b>Root.Parent'Class</b>;
     
        --  Reference an object of type Parent'Class in the test object, so
        --  that test procedures can have access to it.
        type <b>Parent_Test</b> is new Test_Fixture <b>with record</b>
           <b>Fixture : Parent_Access;</b>
        <b>end record</b>;
     
        --  This will initialize P.
        procedure Set_Up (<b>P</b> : in out <b>Parent_Test</b>);
     
        --  Test routines. If derived types are declared in child packages,
        --  these can be in the private part.
        procedure <b>Test_P1</b> (<b>P</b> : in out <b>Parent_Test</b>);
        procedure <b>Test_P2</b> (<b>P</b> : in out <b>Parent_Test</b>);
     
     end <b>Root.Tests</b>;
     
     package body <b>Root.Tests</b> is
     
        <b>Fixture : aliased Parent;</b>
     
        --  We set Fixture in Parent_Test to an object of type Parent.
        procedure Set_Up (<b>P</b> : in out <b>Parent_Test</b>) is
        begin
           <b>P.Fixture := Parent_Access (Fixture'Access)</b>;
        end Set_Up;
     
        --  Test routines: References to the Parent object are made via
        --  P.Fixture.all, and are thus dispatching.
        procedure <b>Test_P1</b> (<b>P</b> : in out <b>Parent_Test</b>) is ...;
        procedure <b>Test_P2</b> (<b>P</b> : in out <b>Parent_Test</b>) is ...;
     
     end <b>Root.Tests</b>;
</pre>
   <p class="noindent">The associated test suite will be:

<pre class="smallexample">     with AUnit.Test_Caller;
     with <b>Root.Tests</b>;
     
     package body <b>Root_Suite</b> is
        package <b>Caller</b> is new AUnit.Test_Caller with (<b>Root.Tests.Parent_Test</b>);
     
        function Suite return AUnit.Test_Suites.Access_Test_Suite is
           <b>Ret</b> : Access_Test_Suite := AUnit.Test_Suites.New_Suite;
        begin
           AUnit.Test_Suites.Add_Test
             (<b>Ret</b>, Caller.Create (<b>"Test Parent : P1"</b>, <b>Root.Tests.Test_P1'Access</b>));
           AUnit.Test_Suites.Add_Test
             (<b>Ret</b>, Caller.Create (<b>"Test Parent : P2"</b>, <b>Root.Tests.Test_P2'Access</b>));
           return <b>Ret</b>;
        end Suite;
     end <b>Root_Suite</b>;
</pre>
   <p class="noindent">Now we define the test suite for the <code>Child</code> type. To do this,
we inherit a test fixture from <code>Parent_Test</code>,
overriding the <code>Set_Up</code> procedure to initialize <code>Fixture</code> with
a <code>Child</code> object. We also override <code>Test_P2</code> to adapt it
to the new implementation. We define a new <code>Test_P3</code> to test
<code>P3</code>. And we inherit <code>Test_P1</code>, since <code>P1</code> is unchanged.

<pre class="smallexample">     with <b>Root.Tests</b>; use <b>Root.Tests</b>;
     with AUnit; use AUnit;
     with AUnit.Test_Fixtures; use AUnit.Test_Fixtures;
     
     package <b>Branch.Tests</b> is
     
        type <b>Child_Test</b> is new <b>Parent_Test</b> <b>with null record</b>;
     
        procedure Set_Up (<b>C</b> : in out <b>Child_Test</b>);
     
        --  Test routines:
        --  Test_P2 is overridden
        procedure <b>Test_P2</b> (<b>C</b> : in out <b>Child_Test</b>);
        --  Test_P3 is new
        procedure <b>Test_P3</b> (<b>C</b> : in out <b>Child_Test</b>);
     
     end <b>Branch.Tests</b>;
     
     package body <b>Branch.Tests</b> is
        use Assertions;
     
        <b>Fixture : Child;</b>
        --  This could also be a field of Child_Test
     
        procedure Set_Up (<b>C</b> : in out <b>Child_Test</b>) is
        begin
           --  The Fixture for this test will now be a Child
           <b>C.Fixture := Parent_Access (Fixture'Access)</b>;
        end Set_Up;
     
        --  Test routines:
        procedure <b>Test_P2</b> (<b>C</b> : in out <b>Child_Test</b>) is ...;
        procedure <b>Test_P3</b> (<b>C</b> : in out <b>Child_Test</b>) is ...;
     
     end <b>Branch.Tests</b>;
</pre>
   <p>The suite for Branch.Tests will now be:

<pre class="smallexample">     with AUnit.Test_Caller;
     with <b>Branch.Tests</b>;
     
     package body <b>Branch_Suite</b> is
        package <b>Caller</b> is new AUnit.Test_Caller with (<b>Branch.Tests.Parent_Test</b>);
     
        --  In this suite, we use Ada 2005 distinguished receiver notation to
        --  simplify the code.
     
        function Suite return Access_Test_Suite is
           Ret : Access_Test_Suite := AUnit.Test_Suites.New_Suite;
        begin
           --  We use the inherited Test_P1. Note that it is
           --  Branch.Tests.Set_Up that will be called, and so Test_P1 will be run
           --  against an object of type Child
           <b>Ret</b>.Add_Test
             (<b>Caller</b>.Create (<b>"Test Child : P1"</b>, <b>Branch.Tests.Test_P1'Access</b>));
           --  We use the overridden Test_P2
           <b>Ret</b>.Add_Test
             (<b>Caller</b>.Create (<b>"Test Child : P2"</b>, <b>Branch.Tests.Test_P2'Access</b>));
           --  We use the new Test_P2
           <b>Ret</b>.Add_Test
             (<b>Caller</b>.Create (<b>"Test Child : P3"</b>, <b>Branch.Tests.Test_P3'Access</b>));
           return <b>Ret</b>;
        end Suite;
     end <b>Branch_Suite</b>;
</pre>
   <h4 class="subsection">7.2.2 Using AUnit.Test_Cases</h4>

<p class="noindent">Using an <code>AUnit.Test_Cases.Test_Case</code> derived type, we obtain the
following code for testing <code>Parent</code>:

<pre class="smallexample">     with AUnit; use AUnit;
     with AUnit.Test_Cases;
     package <b>Root.Tests</b> is
     
        type <b>Parent_Access</b> is access all <b>Root.Parent'Class</b>;
     
        type <b>Parent_Test</b> is new AUnit.Test_Cases.Test_Case <b>with record</b>
           <b>Fixture : Parent_Access;</b>
        <b>end record</b>;
     
        function Name (<b>P</b> : <b>Parent_Test</b>) return Message_String;
        procedure Register_Tests (<b>P</b> : in out <b>Parent_Test</b>);
     
        procedure Set_Up_Case (<b>P</b> : in out <b>Parent_Test</b>);
     
        --  Test routines. If derived types are declared in child packages,
        --  these can be in the private part.
        procedure <b>Test_P1</b> (<b>P</b> : in out <b>Parent_Test</b>);
        procedure <b>Test_P2</b> (<b>P</b> : in out <b>Parent_Test</b>);
     
     end <b>Root.Tests</b>;
</pre>
   <p class="noindent">The body of the test case will follow the usual pattern, declaring one or
more objects of type <b>Parent</b>, and executing statements in the
test routines against them.  However, in order to support dispatching to
overriding routines of derived test cases, we need to introduce class-wide
wrapper routines for each primitive test routine of the parent type that
we anticipate may be overridden. Instead of registering the parent's
overridable primitive operations directly using <code>Register_Routine</code>,
we register the wrapper using <code>Register_Wrapper</code>. This latter routine
is exported by instantiating
<b>AUnit</b><code>.Test_Cases.Specific_Test_Case_Registration</code> with the actual
parameter being the parent test case type.

<pre class="smallexample">     with AUnit.Assertions; use AUnit.Assertions
     package body <b>Root.Tests</b> is
     
        --  Declare class-wide wrapper routines for any test routines that will be
        --  overridden:
        procedure <b>Test_P1_Wrapper</b> (<b>P</b> : in out <b>Parent_Test</b>'Class);
        procedure <b>Test_P2_Wrapper</b> (<b>P</b> : in out <b>Parent_Test</b>'Class);
     
        function Name (<b>P</b> : <b>Parent_Test</b>) return Message_String is ...;
     
        --  Set the fixture in P
        <b>Fixture : aliased Parent;</b>
        procedure Set_Up_Case (<b>P</b> : in out <b>Parent_Test</b>) is
        begin
           <b>P.Fixture := Parent_Access (Fixture'Access)</b>;
        end Set_Up_Case;
     
        --  Register Wrappers:
        procedure Register_Tests (<b>P</b> : in out <b>Parent_Test</b>) is
     
           package <b>Register_Specific</b> is
             new Test_Cases.Specific_Test_Case_Registration (<b>Parent_Test</b>);
     
           use Register_Specific;
     
        begin
           Register_Wrapper (<b>P</b>, <b>Test_P1_Wrapper</b>'Access, <b>"Test P1"</b>);
           Register_Wrapper (<b>P</b>, <b>Test_P2_Wrapper</b>'Access, <b>"Test P2"</b>);
        end Register_Tests;
     
        --  Test routines:
        procedure <b>Test_P1</b> (<b>P</b> : in out Parent_Test) is ...;
        procedure <b>Test_P2</b> (<b>C</b> : in out Parent_Test) is ...;
     
        --  Wrapper routines. These dispatch to the corresponding primitive
        --  test routines of the specific types.
        procedure <b>Test_P1_Wrapper</b> (<b>P</b> : in out <b>Parent_Test</b>'Class) is
        begin
           <b>Test_P1</b> (<b>P</b>);
        end <b>Test_P1_Wrapper</b>;
     
        procedure <b>Test_P2_Wrapper</b> (<b>P</b> : in out <b>Parent_Test</b>'Class) is
        begin
           <b>Test_P2</b> (<b>P</b>);
        end <b>Test_P2_Wrapper</b>;
     
     end <b>Root.Tests</b>;
</pre>
   <p class="noindent">The code for testing the <code>Child</code> type will now be:

<pre class="smallexample">     with <b>Parent_Tests</b>; use <b>Parent_Tests</b>;
     with AUnit; use AUnit;
     package <b>Branch.Tests</b> is
     
        type <b>Child_Test</b> is new <b>Parent_Test</b> <b>with private</b>;
     
        function Name (<b>C</b> : <b>Child_Test</b>) return Message_String;
        procedure Register_Tests (<b>C</b> : in out <b>Child_Test</b>);
     
        --  Override Set_Up_Case so that the fixture changes.
        procedure Set_Up_Case (<b>C</b> : in out <b>Child_Test</b>);
     
        --  Test routines:
        procedure <b>Test_P2</b> (<b>C</b> : in out <b>Child_Test</b>);
        procedure <b>Test_P3</b> (<b>C</b> : in out <b>Child_Test</b>);
     
     private
        type <b>Child_Test</b> is new <b>Parent_Test</b> <b>with null record</b>;
     end <b>Branch.Tests</b>;
     
     with AUnit.Assertions; use AUnit.Assertions;
     package body <b>Branch.Tests</b> is
     
        --  Declare wrapper for Test_P3:
        procedure <b>Test_P3_Wrapper</b> (<b>C</b> : in out <b>Child_Test</b>'Class);
     
        function Name (<b>C</b> : <b>Child_Test</b>) return Test_String is ...;
     
        procedure Register_Tests (<b>C</b> : in out <b>Child_Test</b>) is
     
           package <b>Register_Specific</b> is
              new Test_Cases.Specific_Test_Case_Registration (<b>Child_Test</b>);
           use <b>Register_Specific</b>;
     
        begin
           -- Register parent tests for P1 and P2:
           <b>Parent_Tests</b>.Register_Tests (<b>Parent_Test</b> (<b>C</b>));
     
           -- Repeat for each new test routine (Test_P3 in this case):
           <b>Register_Wrapper</b> (<b>C</b>, <b>Test_P3_Wrapper</b>'Access, <b>"Test P3"</b>);
        end Register_Tests;
     
        --  Set the fixture in P
        <b>Fixture : aliased Child;</b>
        procedure Set_Up_Case (<b>C</b> : in out <b>Child_Test</b>) is
        begin
           <b>C.Fixture := Parent_Access (Fixture'Access)</b>;
        end Set_Up_Case;
     
        --  Test routines:
        procedure <b>Test_P2</b> (<b>C</b> : in out <b>Child_Test</b>) is ...;
        procedure <b>Test_P3</b> (<b>C</b> : in out <b>Child_Test</b>) is ...;
     
        --  Wrapper for new routine:
        procedure <b>Test_P3_Wrapper</b> (<b>C</b> : in out <b>Child_Test</b>'Class) is
        begin
           <b>Test_P3</b> (<b>C</b>);
        end <b>Test_P3_Wrapper</b>;
     
     end <b>Branch.Tests</b>;
</pre>
   <p class="noindent">Note that inherited and overridden tests do not need to be explicitly
re-registered in derived test cases - one just calls the parent version of
<code>Register_Tests</code>. If the application tagged type hierarchy is organized
into parent and child units, one could also organize the test cases into a
hierarchy that reflects that of the units under test.

<!--  -->
<div class="node">
<a name="Testing-generic-units"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#OOP-considerations">OOP considerations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Test-Organization">Test Organization</a>

</div>

<h3 class="section">7.3 Testing generic units</h3>

<p>When testing generic units, one would like to apply the same generic tests
to all instantiations in an application.  A simple approach is to make the
test case a child package of the unit under test (which then must also be
generic).

   <p>For instance, suppose the generic unit under test is a package (it could
be a subprogram, and the same principle would apply):
<pre class="smallexample">     generic
        -- Formal parameter list
     package Template is
        -- Declarations
     end Template;
</pre>
   <p class="noindent">The corresponding test case would be:
<pre class="smallexample">     with AUnit; use AUnit;
     with AUnit.Test_Fixtures;
     generic
     package <b>Template.Gen_Tests</b> is
     
        type <b>Template_Test</b> is new AUnit.Test_Fixtures.Test_Fixture with <b>...</b>;
     
        --  Declare test routines
     
     end <b>Template.Gen_Tests</b>;
</pre>
   <p>The body will follow the usual patterns with the fixture based on the
parent package <code>Template</code>. Note that due to an Ada AI, accesses to
test routines, along with the test routine specifications, must be defined
in the package specification rather than in its body.

   <p>Instances of <code>Template</code> will define automatically the Tests child
package that can be directly instantiated as follow:

<pre class="smallexample">     with Template.Gen_Test;
     with Instance_Of_Template;
     package Instance_Of_Template.Tests is new Instance_Of_Template.Gen_Test;
</pre>
   <p>The instantiated test case objects are added to a suite in the usual manner.

<!-- ================================================================= -->
<div class="node">
<a name="Using-AUnit-with-Restricted-Run-Time-Libraries"></a>
<a name="Using-AUnit-with-Restricted-Run_002dTime-Libraries"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation-and-Use">Installation and Use</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Organization">Test Organization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Using AUnit with Restricted Run-Time Libraries</h2>

<p class="noindent">AUnit 3 - like AUnit 2 - is designed so that it can be used in
environments with restricted Ada run-time libraries, such as ZFP and the cert
run-time profile on Wind River Systems' VxWorks 653.  The patterns given in
this document for writing tests, suites and harnesses are not the only
patterns that can be used with AUnit, but they are compatible with the
restricted run-time libraries provided with GNAT Pro.

   <p>In general, dynamic allocation and deallocation must be used carefully in test
code.  For the cert profile on VxWorks 653, all dynamic allocation must be
done prior to setting the application partition into &ldquo;normal&rdquo; mode. 
Deallocation is prohibited in this profile. For the default ZFP profile,
dynamic memory management is not provided as part of the run-time, as it is
not available on a bare board environment, and should not be used unless
you have provided implementations as described in the GNAT Pro High Integrity
User Guide.

   <p>Starting with AUnit 3, a simple memory management mechanism has been
included in the framework, using a kind of storage pool. This memory
management mechanism uses a static array allocated at startup, and simulates
dynamic allocation afterwards by allocating parts of this array upon request. 
Deallocation is not permitted.

   <p>By default, the allocated array is a 100 KB array. This value can be changed
by modifying its size in the file:
<samp><span class="file">aunit-3.7.0w-src/aunit/framework/staticmemory/aunit-memory.adb</span></samp>

   <p>To allocate a new object, you use <code>AUnit.Memory.Utils.Gen_Alloc</code>.

   <p>Additional restrictions relevant to the default ZFP profile include:
     <ol type=1 start=1>
<li>Normally the ZFP profile requires a user-defined
<code>__gnat_last_chance_handler</code> routine
to handle raised exceptions. However, AUnit now provides a mechanism to
simulate exception propagation using gcc builtin setjmp/longjmp mechanism. 
This mechanism defines the <code>__gnat_last_chance_handler</code> routine, so it
should not be redefined elsewhere.

     <li>AUnit requires <code>GNAT.IO</code> provided in <samp><span class="file">g-io.ad?</span></samp> in the full or cert
profile run-time library sources (or as implemented by the user). Since this
is a run-time library unit it must be compiled with the gnatmake &ldquo;-a&rdquo;
switch.

     <li>The AUnit framework has been modified so that no call to the secondary
stack is performed, nor any call to memcpy or memset. However, if the unit
under test, or the tests themselves require use of those routines, then the
application or test framework must define those symbols and provide the
requisite implementations.

     <li>The timed parameter of the Harness <code>Run</code> routine has no effect when used
with the ZFP profile, and on profiles not supporting Ada.Calendar.
        </ol>

<div class="node">
<a name="Installation-and-Use"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#GPS-Support">GPS Support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-AUnit-with-Restricted-Run_002dTime-Libraries">Using AUnit with Restricted Run-Time Libraries</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Installation and Use</h2>

<ul class="menu">
<li><a accesskey="1" href="#Note-on-gprbuild">Note on gprbuild</a>
<li><a accesskey="2" href="#aunit-project-file-and-support-for-other-platforms_002frun_002dtimes">aunit project file and support for other platforms/run-times</a>
<li><a accesskey="3" href="#Installing-AUnit-on-UNIX-systems">Installing AUnit on UNIX systems</a>
<li><a accesskey="4" href="#Installing-AUnit-on-Windows-systems">Installing AUnit on Windows systems</a>
<li><a accesskey="5" href="#Installing-AUnit-for-customized-run_002dtimes">Installing AUnit for customized run-times</a>
<li><a accesskey="6" href="#Installed-files">Installed files</a>
</ul>

<p class="noindent">AUnit 3 contains support for limited run-times such as zero-foot-print
(ZFP) and certified run-time (cert). It can now be installed simultaneously
for several targets and run-times.

<!--  -->
<div class="node">
<a name="Note-on-gprbuild"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#aunit-project-file-and-support-for-other-platforms_002frun_002dtimes">aunit project file and support for other platforms/run-times</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.1 Note on gprbuild</h3>

<p class="noindent">In order to compile and install AUnit, you need gprbuild. On
cross-platforms gprbuild version 1.1 or later is required, while on native
platforms any version can be used.

<!--  -->
<div class="node">
<a name="aunit-project-file-and-support-for-other-platforms%2frun-times"></a>
<a name="aunit-project-file-and-support-for-other-platforms_002frun_002dtimes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-AUnit-on-UNIX-systems">Installing AUnit on UNIX systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Note-on-gprbuild">Note on gprbuild</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.2 aunit project file and support for other platforms/run-times</h3>

<p>AUnit can be installed once for several targets and run-times. 
To support this, the AUnit project includes scenario variables
to select those targets and/or run-times. The scenario variables
used are:
     <ul>
<li><b>PLATFORM</b>: a free-form value used to differenciate installed libraries. 
This value is set to "native" by default. 
<li><b>RUNTIME</b>: the runtime used to compile AUnit. Many values are defined
there, you can have a look at the aunit_shared project for a comprehensive
list. This scenario variable is used to adapt the AUnit to the run-time profile. 
Is set to "full" by default. 
</ul>

<!--  -->
<div class="node">
<a name="Installing-AUnit-on-UNIX-systems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-AUnit-on-Windows-systems">Installing AUnit on Windows systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#aunit-project-file-and-support-for-other-platforms_002frun_002dtimes">aunit project file and support for other platforms/run-times</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.3 Installing AUnit on UNIX systems</h3>

<p class="noindent">
     <ul>
<li>Extract the archive:
     <pre class="smallexample">             $ gunzip -dc aunit-3.7.0w-src.tgz | tar xf -
</pre>
     <li>To build AUnit for a full Ada run-time:
     <pre class="smallexample">             $ cd aunit-3.7.0w-src
             $ make
</pre>
     <p>To build AUnit for a zfp run-time targeting powerpc-elf platform<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a>:
     <pre class="smallexample">             $ cd aunit-3.7.0w-src
             $ make TARGET=powerpc-elf RTS=zfp
</pre>
     <p>For platforms providing a full Ravenscar run-time (eg. leon3-elf), or when
using ZFP for a native target, add the parameter below that excludes extra
ZFP support for builds using that library:
     <pre class="smallexample">             $ cd aunit-3.7.0w-src
             $ make TARGET=powerpc-elf RTS=ravenscar NO_ZFP_SUPPORT=1
</pre>
     <p>Once the above build procedure has been performed for all
desired platforms, you can install AUnit:
     <pre class="smallexample">             $ make install INSTALL=&lt;gnat-root&gt;
</pre>
     <p>Where &lt;gnat-root&gt; is for example /opt/gnat/6.0.1. If INSTALL is not
specified, then AUnit will use the root directory where gprbuild is installed.

     <li>Specific installation:

     <p>The AUnit makefile supports some specific options, activated using
   environment variables. The following options are defined:

          <ul>
<li><b>INSTALL</b>: defines the AUnit base installation directory, set to
gprbuild's base installation directory as found in the PATH.

          <li><b>TARGET</b>: defines the gnat tools prefix to use. For example, to compile
AUnit for powerpc VxWorks, TARGET should be set to powerpc-wrs-vxworks. If not
set, the native compiler will be used.

          <li><b>RTS</b>:  defines both the run-time used to compile AUnit and the value
given to the AUnit project as RUNTIME scenario variable.

          <li><b>RTS_CONF</b>: defines the gprbuild Runtime config flag. The value is
set to "&ndash;RTS=$(RTS)" by default. Can be used when compiling AUnit for a
configurable run-time. 
</ul>

     <li>To test AUnit:

     <p>The AUnit test suite is in the test subdirectory of the source package.
     <pre class="smallexample">             $ cd test
             $ make
</pre>
     <p>The test suite's makefile supports the following variables:
   * RTS
   * TARGET
</ul>

<!--  -->
<div class="node">
<a name="Installing-AUnit-on-Windows-systems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installing-AUnit-for-customized-run_002dtimes">Installing AUnit for customized run-times</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-AUnit-on-UNIX-systems">Installing AUnit on UNIX systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.4 Installing AUnit on Windows systems</h3>

<p>On Windows, an InstallShield wizard is available to easily install AUnit.

   <p>The InstallShield will go through the following steps:

     <ul>
<li>Selection of the GNAT compiler to consider: this page allows you to select
which GNAT compiler to use to compile AUnit.

     <li>Selection of the directory used to install AUnit: by default the same directory
as the GNAT compiler.

     <li>Selection of targets: the InstallShield will try to detect all GNAT compilers
available on your system. You can then select the compilers/runtimes that you
want AUnit installed for.

     <li>At this stage, the AUnit library starts compiling. And is then installed in the
destination directory. 
</ul>

   <p>Note that in contrast to the AUnit 2 installation procedures, support for
exception handling, memory allocation and Ada.Calendar is automatically
selected depending on the run-times used.

<!--  -->
<div class="node">
<a name="Installing-AUnit-for-customized-run-times"></a>
<a name="Installing-AUnit-for-customized-run_002dtimes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installed-files">Installed files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-AUnit-on-Windows-systems">Installing AUnit on Windows systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.5 Installing AUnit for customized run-times</h3>

<p class="noindent">The AUnit library can also be compiled for custom-built run-times. To do so,
you can either use the Makefile (see <a href="#Installing-AUnit-on-UNIX-systems">Installing AUnit on UNIX systems</a>) or
use directly the project aunit_build.gpr that is installed in &lt;prefix&gt;/lib/gnat.

   <p>To use the Makefile, you will need to specify RTS_CONF so that the correct
parameter is passed to gprbuild. For example, if your custom run-time is
powerpc-elf/ravenscar-full-prep, then you need to use the command:

<pre class="smallexample">     make TARGET=powerpc-elf RTS=ravenscar-full \
       RTS_CONF=--RTS=powerpc-elf/ravenscar-full-prep
</pre>
   <p>If AUnit comes pre-installed or you can't use the Makefile, then you can also
directly use the aunit_build.gpr project file to compile and use AUnit.

<pre class="smallexample">     gprbuild --target=powerpc-elf --RTS=powerpc-elf/ravenscar-full-prep \
       -XPLATFORM=powerpc-elf -XRUNTIME=ravenscar-full -Paunit_build -p
</pre>
   <p>The aunit_build project will install the AUnit library in &lt;prefix&gt;/lib/aunit/&lt;TARGET&gt;-&lt;RUNTIME&gt; and use the object directory &lt;prefix&gt;/lib/aunit-obj/&lt;TARGET&gt;-&lt;RUNTIME&gt;.

   <p>If the AUnit installation directory is readonly, you can override those paths
 by setting the LIBDIR and OBJDIR scenario variables. Note that you still need
 to provide the RUNTIME scenario variable in this case, but PLATFORM can be
 omitted:

<pre class="smallexample">     gprbuild --target=powerpc-elf --RTS=powerpc-elf/ravenscar-full-prep \
       -XRUNTIME=ravenscar-full LIBDIR=$HOME/aunit-lib OBJDIR=/tmp -Paunit_build
</pre>
   <p>Once built this way, the object directory can safely be removed, and you can
use the regular aunit project to build your test suites.

<!--  -->
<div class="node">
<a name="Installed-files"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installing-AUnit-for-customized-run_002dtimes">Installing AUnit for customized run-times</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Use">Installation and Use</a>

</div>

<h3 class="section">9.6 Installed files</h3>

<p class="noindent">The AUnit library is installed in the specified directory (&lt;aunit-root&gt;
identifies the root installation directory as specified during the installation
procedures above):

     <ul>
<li>   the aunit.gpr project is installed in &lt;aunit-root&gt;/lib/gnat
<li>   the AUnit source files are installed in &lt;aunit-root&gt;/include/aunit
<li>   the AUnit library files are installed in &lt;aunit-root&gt;/lib/aunit
<li>   the AUnit documentation is installed in &lt;aunit-root&gt;/share/doc/aunit
<li>   the AUnit examples are installed in &lt;aunit-root&gt;/share/examples/aunit
</ul>

<div class="node">
<a name="GPS-Support"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation-and-Use">Installation and Use</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 GPS Support</h2>

<p class="noindent">GPS IDE relies on gnattest tool that creates unit-test skeletons as well as
a test driver infrastructure (harness). Harness can be generated for project
hierarchy, single project or a package. Generation process can be launched
from <b>Tools -&gt; GNATtest</b> menu or from contextual menu.

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> While JUnit and some other
members of the xUnit family of unit test frameworks provide specialized forms
of assertions (e.g. <code>assertEqual</code>), we took a design decision in AUnit
not to provide such forms.  Ada has a much more rich type system giving a
plethora of possible scalar types, and leading to an explosion of possible
special forms of assert routines.  This is exacerbated by the lack of a single
root type for most types, as is found in Java.  With the introduction of
AUnit 2 for use with restricted run-time profiles, where even 'Image is
missing, providing a comprehensive set of special assert routines in the
framework itself becomes even more unrealistic. Since AUnit is intended to
be an extensible toolkit, users can certainly write their own custom
collection of such assert routines to suit local usage.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> Note that in AUnit 3, and contrary to
AUnit 2, the procedural form of <code>Assert</code> has the same behavior whatever
the underlying Ada run-time library: a failed assertion will cause the
execution of the calling test routine to be abandoned. The functional form of
<code>Assert</code> always continues on a failed assertion, and provides you
with a choice of behaviors.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> If using the ZFP or the 'cert' run-time profiles, test
 cases and suites must be allocated using
 <code>AUnit.Memory.Utils.Gen_Alloc</code>, <code>AUnit.Test_Caller.Create</code>,
 <code>AUnit.Test_Suites.New_Suite</code>, or be statically allocated.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> 
Note that cross platforms require gprbuild version 1.1 or later</p>

   <hr></div>

</body></html>

