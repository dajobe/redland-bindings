#
#   This work was created by the National Center for Ecological Analysis and Synthesis.
#
#     Copyright 2014
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

library(XML)
library(redland)
library(brew)

# This function creates documentation files for the wrapper functions contained in redland/redland.R
# that make the Redland RDF C library functions available to R. The wrapper file redland.R is
# generated by SWIG, and does not contain any user oriented documentation. This script
# combines documentation from the Redland RDF C source tree and the loaded functions in R
# to create Roxygen files int he redland/man directory for each wrapper function.
# The original C source documentation contains GTKdoc style comments in the C source, which
# are converted to XML, then HTML in the docs/Makefile in the source tree. This R
# script is only intended to be run by redland-bindings developers, and so is not included
# in the R/redland R package for distribution to end users.
# This function is called by the R/Makefile 'librdfDocs' target. In order to build
# the docs, you must:
#    1) download the redland C library source, i.e. https://github.com/dajobe/librdf
#    2) Build the documentation, which creates the ./docs/xml/* files
#    3) edit the Makefile to change redlandDocDir to your redland source directory
#    4) make librdfDocs
#
# Author: Peter Slaughter <slaughter@nceas.ucsb.edu>
# Date: March, 2015
#
mkDocs <- function (redlandDocDir, verbose=FALSE, librdfDocsURL="http://librdf.org/docs/") {

  # Does the Redland source tree exist, with the generated xml/* files?
  if (! file.exists(redlandDocDir)) {
      stop(sprintf("The specified location of the redland api docs \"%s\" does not exist\n", redlandDocDir))
  }
  outDir <- "redland/man"
  #trim <- function (x) gsub("^\\s+|\\s+$", "", x)
  # Read in the XML file that contains an index of all librdf functions, macros, etc
  indexFile <- sprintf("%s/xml/api-index-full.xml", redlandDocDir)
  stopifnot(file.exists(indexFile))
  indexDoc <- xmlInternalTreeParse(indexFile)
  nodes <- getNodeSet(indexDoc, "//primaryie")
  # Total list of sections is
  sections <- c("parser", "hash", "statement", "query", "query_results", "storage", "model", "world", 
                "stream", "digest", "node", "serializer", "digest", "stream", "uri", "general", "iterator", "log")
  sectionDocs <- list()
  sectionNames <- list()
  # Load an XML for each section needed.
  for (iSec in sections) {
    sectionDocFile <- sprintf("%s/xml/%s.xml", redlandDocDir, iSec)
    if (verbose) cat(sprintf("loading doc file: %s\n", sectionDocFile))
    sectionDocs <- c(sectionDocs, xmlInternalTreeParse(sectionDocFile))
    sectionNames <- c(sectionNames, iSec)
  }

  names(sectionDocs) <- sectionNames
  # Loop through each function in the API index file, see if it has been loaded in the 
  # redland package namespace (i.e. was defined in the redland.R script and loaded with library(redland))
  for (node in nodes) {
    # The node value is mixed content, with the function (or macro, etc.) value in the first
    # <link> element, and the category name that this function is in, in the second <link> element
    functionName <- xmlValue(getNodeSet(node, "./link")[[1]])
    functionSection <- xmlValue(getNodeSet(node, "./link")[[2]])
    # See if the name was loaded into the redland namespace
    searchPattern <- sprintf("^%s$", functionName)
    packMemName <- ls("package:redland", pattern=searchPattern)
    if (length(packMemName) > 0) {
      if (is.element(functionSection, names(sectionDocs))) {
        #if (functionName != "rasqal_version_release_get") next
        if (verbose) cat(sprintf("processing functionName: %s\n", functionName))
        xPathStr <- sprintf('/refentry/refsect1/refsect2[./indexterm/primary="%s"]', functionName)
        entryTop <- getNodeSet(sectionDocs[[functionSection]], xPathStr)[[1]]
        # Obtain the function usage string from the loaded R function, not from the C api docs,
        # because we want to document the R parameter types of the wrapper, not the C types
        # from the redland library api docs. The SWIG wrapper "redland.R" creates each wrapped
        # function with R attributes for the fuction input and return R types.
        functionInputs <- formals(functionName)
        functionInputNames <- names(functionInputs)
        functionParamNames <- list()
        for (argName in functionInputNames) {
          functionParamNames <- c(functionParamNames, argName)
        }
        functionInputTypes <- attr(eval(parse(text=functionName)), "inputTypes")
        # Format the function inputs
        #functionInputs <- paste(lapply(functionInputs, function(x) { s <- gsub('^', '"', x) ; s <- gsub('$', '"', s) }), collapse=", ")
        returnValue <- attr(eval(parse(text=functionName)), "returnType")
        functionDescr <- xmlValue(getNodeSet(entryTop, "./para")[[1]])
        paramNameNodes <- getNodeSet(entryTop, './refsect3[@role="parameters"]/informaltable//entry[@role="parameter_name"]')
        functionParamDescr <- list()

        # We have the param names and types from R, now just get the param descriptions from the api docs
        for (pNode in paramNameNodes) {
          #paramName <- xmlValue(getNodeSet(pNode, './informaltable//entry[@role="parameter_name"]/para')[[1]])
          paramName <- xmlValue(pNode)
          if (paramName == "") {
	    next 
          }
          paramDescr <- xmlValue(getNodeSet(pNode, '../entry[@role="parameter_description"]/para')[[1]])
          functionParamDescr <- c(functionParamDescr, paramDescr)
        }

        # Build the function usage string
        functionUsage <- sprintf("%s ( %s )", functionName, paste(functionParamNames, collapse=",\n\t"))
        # Append the R datatype to the function description
        if (!is.null(functionParamDescr)) {
          itype <- 0;
          for (inputType in functionInputTypes) {
            itype <- itype + 1;
               functionParamDescr[itype] <- sprintf('%s ("%s")', functionParamDescr[itype], functionInputTypes[[itype]])
          }
        }

        # The function param description list obtained from the api docs may be shorter that
        # the list of arguments obtained from the function closure, so pad the param description list if needed.
        if(length(functionParamNames) > length(functionParamDescr)) {
          lengthDiff <- length(functionParamNames) - length(functionParamDescr)
          functionParamDescr <- c(functionParamDescr, as.list(rep(NA, times=lengthDiff)))
        }
        # Print out copious info if verbose is on.
        if (verbose) {
          cat(sprintf("functionDescr %s\n", functionDescr))
          cat(sprintf("functionUsage: %s\n", functionUsage))
          cat(sprintf("functionName: %s\n", functionName))
          cat(sprintf("functionDescr: %s\n", functionDescr))
          iparam <- 0
          for (paramName in functionParamNames) {
            iparam <- iparam + 1 
            cat(sprintf("functionParamNames[[%d]]: %s\n", iparam, functionParamNames[[iparam]]))
            cat(sprintf("functionParamDescr[[%d]]: %s\n", iparam, functionParamDescr[[iparam]]))
          }
          cat(sprintf("returnValue: %s\n", returnValue))
        }
        outFile <- sprintf("%s/%s.Rd", outDir, functionName)
        if (verbose) cat(sprintf("calling brew on file: %s\n", outFile))
        # Call the template engine, it will substitute local variables such as "functionName" into the template
        brew("./librdfFunction.brew", outFile)
      } else {
        message(sprintf("Error, document not loaded for section %s\n", functionSection))
      }
    }
  }
  if (verbose) cat(sprintf("Done!\n"))
}

#mkDocs(redlandDocDir="/Users/slaughter/Software/Redland/redland-1.0.17/docs", verbose=FALSE, librdfDocsURL="http://librdf.org/docs")
