<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">Writing Ada Bindings for a C Library</title><meta name="DCTERMS.title" content="Writing Ada Bindings for a C Library" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Victor Porton"/><meta name="DCTERMS.issued" content="2014-10-28T23:47:01.014856733" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Victor Porton"/><meta name="DCTERMS.modified" content="2017-10-29T17:53:09.911198906" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content=", Ada bindings, thick bindings, C" xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both;}
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	/* "li span.odfLiEnd" - IE 7 issue*/
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	span.heading_numbering { margin-right: 0.8rem; }* { margin:0;}
	.Header { font-size:10pt; font-family:Arial; writing-mode:lr-tb; letter-spacing:0.0138in; }
	.MH_20_Main_20_heading { font-size:13pt; font-family:Times New Roman; writing-mode:page; margin-top:0.0835in; margin-bottom:0.0835in; line-height:0.1807in; font-weight:bold; }
	.My_20_program { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P1_borderStart { border-left-style:none; border-right-style:none; border-top-width:0.0349cm; border-top-style:solid; border-top-color:#000000; font-size:10pt; letter-spacing:0.0138in; padding-left:0in; padding-right:0in; padding-top:0.028in; font-family:Arial; writing-mode:lr-tb;  border-bottom-style:none; }
	.P1 { border-left-style:none; border-right-style:none; font-size:10pt; letter-spacing:0.0138in; padding-left:0in; padding-right:0in; font-family:Arial; writing-mode:lr-tb;  border-top-style:none; border-bottom-style:none; }
	.P1_borderEnd { border-bottom-style:none; border-left-style:none; border-right-style:none; font-size:10pt; letter-spacing:0.0138in; padding-bottom:0in; padding-left:0in; padding-right:0in; font-family:Arial; writing-mode:lr-tb;  border-top-style:none;}
	.P10 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P11 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P12 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P13 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P14 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P15 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P16 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P17 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P18 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P19 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P20 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P21 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P22 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P23 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P24 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P25 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P26 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P27 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P28 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P29 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P3 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P30 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P31 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P32 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P33 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P34 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P35 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P36 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P37 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P38 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P39 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P4 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P40 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P41 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P42 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P43 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P44 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P45 { font-size:12pt; font-style:italic; font-weight:bold; line-height:0.1665in; margin-bottom:0.0417in; margin-top:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P46 { font-size:11pt; font-style:italic; line-height:0.1665in; margin-bottom:0.0835in; margin-top:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P47 { font-size:11pt; font-style:italic; line-height:0.1665in; margin-bottom:0.0835in; margin-left:0in; margin-right:0in; margin-top:0in; text-align:justify ! important; text-indent:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P48 { font-size:11pt; font-style:italic; line-height:0.1665in; margin-bottom:0.0835in; margin-left:0in; margin-right:0in; margin-top:0in; text-align:justify ! important; text-indent:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P49 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P5 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P50 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P51 { font-size:11pt; font-style:italic; line-height:0.1665in; margin-bottom:0.0835in; margin-top:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P52 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P53 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P54 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P55 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P56 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P57 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P58 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P59 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P6 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P60 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; }
	.P61 { font-size:24pt; line-height:0.4165in; margin-bottom:0.1665in; margin-top:0in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P62 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P63 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P64 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P65 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P66 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P67 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P68 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P69 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:page; }
	.P7 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P70 { font-size:13pt; font-weight:bold; line-height:0.1807in; margin-bottom:0.0835in; margin-top:0.0835in; font-family:Times New Roman; writing-mode:lr-tb; }
	.P71 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P8 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.P9 { font-size:10pt; line-height:0.1665in; margin-bottom:0.0402in; margin-top:0.0402in; text-align:justify ! important; font-family:Times New Roman; writing-mode:lr-tb; }
	.TP_20_Text_20_para { font-size:10pt; font-family:Times New Roman; writing-mode:lr-tb; margin-top:0.0402in; margin-bottom:0.0402in; line-height:0.1665in; text-align:justify ! important; }
	.Sect1 { writing-mode:lr-tb; }
	.Internet_20_link { color:#000080; text-decoration:underline; }
	.PC_20_Program_20_char { font-family:Arial; font-size:9pt; }
	.Page_20_Number { font-weight:bold; }
	.RW_20_Reserved_20_word { font-size:9pt; font-family:Arial; font-weight:bold; }
	.T18 { font-style:italic; }
	.T19 { font-style:italic; }
	.T41 { font-style:normal; }
	.T42 { font-style:normal; }
	.T44 { color:#444444; font-family:monospace, sans-serif; font-size:9pt; letter-spacing:normal; font-style:normal; font-weight:normal; }
	.T7 { font-style:italic; }
	.Teletype { font-family:Liberation Mono; }
	/* ODF styles with no properties representable as CSS */
	.Footnote_20_Symbol .Numbering_20_Symbols .T1 .T10 .T11 .T12 .T13 .T14 .T15 .T16 .T17 .T2 .T20 .T21 .T22 .T23 .T24 .T25 .T26 .T27 .T28 .T29 .T30 .T31 .T32 .T33 .T34 .T35 .T36 .T37 .T38 .T39 .T40 .T43 .T45 .T46 .T47 .T48 .T49 .T5 .T50 .T51 .T52 .T53 .T54 .T55 .T56 .T57 .T58 .T59 .T6 .T60 .T61 .T62 .T63 .T64 .T65 .T66 .T67 .T68 .T69 .T70 .T71 .T8 .T9 .WW8Num1z0  { }
	</style></head><body dir="ltr" style="max-width:8.2681in;margin-top:0.4165in; margin-bottom:0.5in; margin-left:0.6335in; margin-right:0.6335in; "><p class="P61">Writing Ada Bindings for a C Library</p><p class="P45"><span class="T20">Victor</span> <span class="T20">Porton</span></p><p class="P46"><span class="T21">Shay Agnon 32-29, Ashkelon, Israel</span>; email: <span class="T21">porton@narod.ru</span></p><p class="P51"> </p><!--Next 'div' was a 'text:section'.--><div class="Sect1" id="Section1"><ol><li><h class="P62" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">1.</span><a id="a_1__Abstract">Abstract</a><span class="odfLiEnd"/> </h></li></ol><p class="P48">I share my experience <span class="T57">of </span>writing thick (object oriented) Ada binding of a C library. This article provides some Ada tips and tricks (especially for Ada bindings writers).</p><p class="P47">Keywords: <span class="T22">Ada bindings, thick bindings, C</span>.</p><ol><li><h class="P62" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">2.</span><a id="a_2__Introduction">Introduction</a><span class="odfLiEnd"/> </h></li></ol><p class="P3">We have a C library, written in object oriented style (C <span class="T23">structure </span>pointers serve as objects, and <span class="T23">C functions taking such structure pointers serve as methods</span>). However there is no inheritance in that C library <span class="T24">(to make things easier for us)</span>.</p><p class="P25"><span class="T5">The particular library is </span><span class="T7">Redland</span><span class="T18"> RDF Librar</span><span class="T19">ies</span>, <span class="T25">a set of libraries which parses RDF files or other RDF resources and manages them, allows to do RDF queries, etc. Don't worry if you don't know what RDF is, it is not really relevant for this article. See more info about this C library in </span><span class="T16"><a href="#__RefNumPara__6380_3978438061">[4]</a></span><span class="T16"> </span><span class="T17">and </span><span class="T17"><a href="#__RefNumPara__6535_3978438061">[1]</a></span><span class="T25"> and on RDF itself in </span><span class="T25"><a href="#__RefNumPara__6537_3978438061">[3]</a></span><span class="T25">.</span></p><p class="P26">I write <span class="T18">thick</span> Ada bindings for this library. “Thick” means that the API which I create is a full fledged Ada <span class="T26">interface. For example, it uses Ada controlled tagged types to represent objects. (It also uses derived types and some other Ada features which are not available in C.)</span></p><p class="P33">By Ada here I will mean Ada2012, the latest <span class="T31">currently </span>available Ada standard.</p><p class="P34">This is a work in progress. Please write your comments. Don’t forget to notify me through <a href="mailto:porton@narod.ru" class="Internet_20_link">porton@narod.ru</a> (as I am <span class="T18">not</span><span class="T41"> subscribed to this journal).</span></p><p class="P40"><span class="T41">The source code of my library is available at </span><a href="https://github.com/vporton/redland-bindings" class="Internet_20_link"><span class="T41">https://github.com/vporton/redland-bindings</span></a><span class="T41"> (currently only in </span><span class="Teletype"><span class="T41">ada2012</span></span><span class="T41"> branch</span><span class="T42">)</span><span class="T41">.</span></p><p class="P41"><span class="T41">Note that the main purpose I created Ada bindings for Redland is to use them in this project:<br/></span><a href="https://en.wikiversity.org/wiki/Automatic_transformation_of_XML_namespaces" class="Internet_20_link"><span class="T41">https://en.wikiversity.org/wiki/Automatic_transformation_of_XML_namespaces</span></a></p><ol><li><h class="P70" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">3.</span><a id="a_3__Little_things">Little things</a><span class="odfLiEnd"/> </h></li></ol><p class="P35">One thing I learned during this project, is that Ada types should have different names, they shouldn’t have the same name even if they are in different packages. This both allows to shorten the code with use directives and to increase reliability of not passing a wrong type if a use directive is indeed used.</p><p class="P39"><span class="T48">Initially I tried to use GCC with </span><span class="T44">-fdump-ada-spec</span><span class="T48"> flag to autogenerate Ada specs from C headers. But shortly I realized that it will work better if I write </span><span class="PC_20_Program_20_char"><span class="T48">Convention=&gt;C</span></span><span class="T48"> subprograms manually (mainly because I sometimes way </span><span class="PC_20_Program_20_char"><span class="T48">char_array</span></span><span class="T48"> and sometimes </span><span class="PC_20_Program_20_char"><span class="T48">chars_ptr</span></span><span class="T48"> for a char* argument of a C function).</span></p><ol><li><h class="P64" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">4.</span><a id="a_4__Packages_structure">Packages structure</a><span class="odfLiEnd"/> </h></li></ol><p class="P27">I put all my API into package hierarchy <span class="PC_20_Program_20_char">RDF.*</span>.</p><p class="P27">The package <span class="PC_20_Program_20_char">RDF</span> itself is empty:</p><p class="P55"><span class="RW_20_Reserved_20_word">package</span> RDF <span class="RW_20_Reserved_20_word">is</span></p><p class="P50">   <span class="RW_20_Reserved_20_word"><span class="T49">pragma</span></span><span class="T49"> Pure(RDF)</span><span class="RW_20_Reserved_20_word"><span class="T49">;</span></span><span class="RW_20_Reserved_20_word"><br/>end</span> RDF;</p><p class="P28">I also have <span class="PC_20_Program_20_char">RDF.Auxiliary</span> package and its subpackages for “auxiliary” things <span class="T28">(things used by or with my bindings, but not being bindings for a particular C library function)</span>.</p><p class="P29">I will discuss some particular <span class="PC_20_Program_20_char"><span class="T27">RDF.Auxiliary.*</span></span><span class="T27"> package</span>s below.</p><ol><li><h class="P65" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">5.</span><a id="a_5__My_tagged_types">My tagged types</a><span class="odfLiEnd"/> </h></li></ol><p class="P32">As I've said above, C objects are pointers to structures. All C pointers to structures have the same format and alignment <span class="T29"><a href="#__RefNumPara__6410_3978438061">[2]</a></span>. This allows to represent any pointers to C structures as pointers to <span class="PC_20_Program_20_char">Dummy_Record</span> as defined in <span class="PC_20_Program_20_char"><span class="T6">RDF.Auxiliary</span></span> <span class="T29">package:</span></p><p class="My_20_program"><span class="RW_20_Reserved_20_word">type</span> Dummy_Record <span class="RW_20_Reserved_20_word">is</span> <span class="RW_20_Reserved_20_word">null</span> <span class="RW_20_Reserved_20_word">record</span><br/>  <span class="RW_20_Reserved_20_word">with</span> Convention=&gt;C;</p><p class="P42">A new Ada type<span class="T56"> (call it </span><span class="PC_20_Program_20_char"><span class="T56">T_Without_Finalize</span></span><span class="T56"> for the below explained reasons)</span> corresponding to a dynamically allocated C record is create<span class="T58">d</span> by instantiating <span class="T55">generic packages</span> <span class="PC_20_Program_20_char"><span class="T32">RDF.Auxiliary.Handled_Record</span></span> or <span class="PC_20_Program_20_char"><span class="T32">RDF.Auxiliary.Limited_Handled_Record</span></span> with a <span class="PC_20_Program_20_char">Convention=&gt;C</span> record type (can be <span class="PC_20_Program_20_char">Dummy_Record</span> if record layout is considered internal by the C library documentation) and a <span class="PC_20_Program_20_char">Convention=&gt;C</span> access to this record <span class="T56">and deriving our type from the tagged type </span><span class="PC_20_Program_20_char"><span class="T56">Base_Object</span></span><span class="T56"> in the instantiated package</span>.</p><p class="P31"><span class="T59">R</span>epresenting C structure pointers as tagged types is not memory efficient, but here we trade efficiency for programming ease.</p><p class="P30">It would be compelling to make <span class="PC_20_Program_20_char">Limited_Handled_Record</span> a descendant type of  <span class="PC_20_Program_20_char">Handled_Record</span>, but it is impossible in Ada because <span class="PC_20_Program_20_char">Ada.Finalization.Limited_Controlled</span> is not a descendant of <span class="PC_20_Program_20_char">Ada.Finalization.Controlled</span> (as it probably should be). <span class="T30">As such I wrote two similar packages </span><span class="PC_20_Program_20_char"><span class="T30">RDF.Auxiliary.Limited_Handled_Record</span></span><span class="T30"> and </span><span class="PC_20_Program_20_char"><span class="T30">RDF.Auxiliary.Handled_Record</span></span><span class="T30"> which duplicate mainly the same code. This is not perfect, but neither it is very bad, as the quantity of the code of these two packages (including their bodies) is not great.</span></p><ol><li><h class="P66" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">6.</span><a id="a_6__About_finalization_and_related_stuff">About finalization and related stuff</a><span class="odfLiEnd"/> </h></li></ol><p class="P4">The main challenge writing object oriented bindings for a C library is <span class="T18">finalization</span>.</p><p class="P5">In the C library in consideration (as well as in many other C libraries) every object is represented as a pointer to a dynamically allocated C structure.</p><p class="P6">The corresponding Ada object can be a <span class="T69">(tagged)</span> record holding the pointer (<span class="T34">aka </span><span class="T18">handle</span>).</p><p class="P4">Ada object representing C objects should be descendants of <span class="PC_20_Program_20_char"><span class="T33">Ada.Finalization.Limited_Controlled</span></span><span class="T33"> </span>or<span class="T33"> </span><span class="PC_20_Program_20_char"><span class="T33">Ada.Finalization.Controlled</span></span> to be properly finalized when appropriate.</p><p class="P7">But oftentimes a C function returns so called “shared handle” that is a pointer to a C struct which we should not free because it is a part of a greater C object and shall be freed (by the C library) only when that greater C object goes away.</p><p class="P8">As such I first define <span class="T35">a tagged type </span><span class="PC_20_Program_20_char"><span class="T35">T_Without_Finalize</span></span><span class="T35"> type. For this type I define such procedures as </span><span class="PC_20_Program_20_char"><span class="T35">Do_Finalize</span></span><span class="T35"> and </span><span class="PC_20_Program_20_char"><span class="T35">Do_Adjust</span></span><span class="T35"> which do what </span><span class="PC_20_Program_20_char"><span class="T35">Finalize</span></span><span class="T35"> and </span><span class="PC_20_Program_20_char"><span class="T35">Adjust</span></span><span class="T35"> should do but leave </span><span class="PC_20_Program_20_char"><span class="T35">Finalize</span></span><span class="T35"> and </span><span class="PC_20_Program_20_char"><span class="T35">Adjust</span></span><span class="T35"> empty, so that a shared handle is neither finalized nor copied.</span></p><p class="P9">I define type <span class="PC_20_Program_20_char">T</span> with <span class="PC_20_Program_20_char">Finalize</span> and <span class="PC_20_Program_20_char">Adjust</span> as a derived type. <span class="PC_20_Program_20_char">T</span> could be defined as ancestor of both <span class="PC_20_Program_20_char"><span class="T35">T_Without_Finalize</span></span><span class="T35"> </span>and a type which defines <span class="PC_20_Program_20_char">Finalize</span> and <span class="PC_20_Program_20_char">Adjust</span>. But as Ada misses inheritance from multiple tagged types, I do it with generics instead <span class="T36">(below is a partial listing)</span>:</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">generic</span></p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">type</span> Base is <span class="RW_20_Reserved_20_word">new</span> Base_Object <span class="RW_20_Reserved_20_word">with</span> <span class="RW_20_Reserved_20_word">private</span>;</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">package</span> Common_Handlers <span class="RW_20_Reserved_20_word">is</span></p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">type</span> User_Type <span class="RW_20_Reserved_20_word">is</span> <span class="RW_20_Reserved_20_word">new</span> Base <span class="RW_20_Reserved_20_word">with</span> <span class="RW_20_Reserved_20_word">null</span> <span class="RW_20_Reserved_20_word">record</span>;</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">overriding</span> <span class="RW_20_Reserved_20_word">procedure</span> Finalize(Object: <span class="RW_20_Reserved_20_word">in</span> <span class="RW_20_Reserved_20_word">out</span> User_Type)</p><p class="My_20_program">                                <span class="RW_20_Reserved_20_word">renames</span> Do_Finalize;</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">overriding</span> <span class="RW_20_Reserved_20_word">procedure</span> Adjust(Object: <span class="RW_20_Reserved_20_word">in</span> <span class="RW_20_Reserved_20_word">out</span> User_Type)</p><p class="My_20_program">                              <span class="RW_20_Reserved_20_word">renames</span> Do_Adjust;</p><p class="P52">  <span class="RW_20_Reserved_20_word">type</span> Base_With_Finalization <span class="RW_20_Reserved_20_word">is</span> <span class="RW_20_Reserved_20_word">new</span> User_Type</p><p class="P52">    <span class="RW_20_Reserved_20_word">with</span> <span class="RW_20_Reserved_20_word">null</span> <span class="RW_20_Reserved_20_word">record</span>;</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">end</span>;</p><p class="TP_20_Text_20_para">The <span class="PC_20_Program_20_char">Base</span> generic parameter is intended to be that <span class="PC_20_Program_20_char"><span class="T35">T_Without_Finalize</span></span> type.</p><p class="TP_20_Text_20_para">You see that <span class="PC_20_Program_20_char"><span class="T35">Do_Finalize</span></span><span class="T35"> and </span><span class="PC_20_Program_20_char"><span class="T35">Do_Adjust</span></span><span class="T35"> become actual handlers of finalization and adjustment.</span></p><p class="TP_20_Text_20_para">Note that I recommend to override the subprograms <span class="PC_20_Program_20_char">Finalize_Handle</span> and <span class="PC_20_Program_20_char">Adjust_Handle</span> (see the source) rather than <span class="PC_20_Program_20_char"><span class="T35">Do_Finalize</span></span><span class="T35"> and </span><span class="PC_20_Program_20_char"><span class="T35">Do_Adjust</span></span><span class="T35"> </span>themselves.</p><p class="TP_20_Text_20_para">Note that values of  <span class="PC_20_Program_20_char"><span class="T35">T_Without_Finalize</span></span><span class="T37"> type </span>may become invalid (containing dangling access values). There seems that there is no easy enough way to deal with this problem <span class="T47">(because of the way the C library works)</span>. Just be careful when using this library not to use objects which are already destroyed.</p><ol><li><h class="P67" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">7.</span><a id="a_7__User_defined_types">User defined types</a><span class="odfLiEnd"/> </h></li></ol><p class="TP_20_Text_20_para">Next thing to note that I first define <span class="PC_20_Program_20_char">User_Type</span>. This type is intended to serve among other as a base for user-defined types which may contain not only the C handle but also other fields. <span class="T38">The type </span><span class="PC_20_Program_20_char"><span class="T38">Base_With_Finalization</span></span><span class="T38"> on the other hand is meant not to be a base for types with additional fields but contain only the handle (and null record extensions).</span></p><p class="TP_20_Text_20_para">The reason why I make distinction between <span class="PC_20_Program_20_char"><span class="T37">User_Type</span></span> and <span class="PC_20_Program_20_char"><span class="T38">Base_With_Finalization</span></span> is the following:</p><p class="TP_20_Text_20_para">We define some functions like</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">function</span> From_Filename</p><p class="P53">  (World: Raptor_World_Type_Without_Finalize'Class;</p><p class="P53">   Filename: String)</p><p class="P49">    <span class="RW_20_Reserved_20_word">return</span> IOStream_Type;</p><p class="TP_20_Text_20_para"><span class="PC_20_Program_20_char">IOStream_Type</span> is derived from <span class="PC_20_Program_20_char">Base_With_Finalization</span> not from <span class="PC_20_Program_20_char">User_Type</span> directly. <span class="T39">If we derived our </span><span class="PC_20_Program_20_char"><span class="T39">User_Type</span></span><span class="T39"> from </span><span class="PC_20_Program_20_char">IOStream_Type</span><span class="T39"> then non-null record extensions would cause (by Ada rules) the necessity to redefine </span><span class="PC_20_Program_20_char"><span class="T39">From_Filename</span></span><span class="T39"> function also for the derived type what is a nonsense.</span></p><p class="TP_20_Text_20_para">We actually use <span class="PC_20_Program_20_char">User_Type</span> <span class="T40">(in the private part of a package) </span>like this <span class="T40">(for an I/O stream reading from a string)</span>:</p><p class="P54"><span class="RW_20_Reserved_20_word">type</span> Stream_From_String(Length: size_t) <span class="RW_20_Reserved_20_word">is</span></p><p class="P54">  <span class="RW_20_Reserved_20_word">new</span> IOStream_Type_User <span class="RW_20_Reserved_20_word">with</span></p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">record</span></p><p class="My_20_program">    Str: char_array(1..Length);</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">end</span> <span class="RW_20_Reserved_20_word">record</span>;</p><ol><li><h class="P68" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">8.</span><a id="a_8__Controlling_vs_class-wide_arguments">Controlling vs class-wide arguments</a><span class="odfLiEnd"/> </h></li></ol><p class="P14">Controlling and class-wide arguments differ mainly in their relationship with inheritance. But as there is no inheritance in the C library which we bind, we have certain freedom to choose either.</p><p class="P21">One disadvantage of class-wide types is that <span class="T60">such things as </span>that is makes <span class="T61">necessary Get_Handle(null) to be type-qualified and thus the subprogram specifications longer.</span></p><p class="P23"><span class="T62">One advantage of class-wide types is that I can use (as in query_results.ads) </span><span class="PC_20_Program_20_char"><span class="T62">ST‘Class</span></span><span class="T62"> where </span><span class="PC_20_Program_20_char"><span class="T62">ST</span></span><span class="T62"> is a subtype with a predicate to restrict to a subtypes matching a predicate.</span></p><p class="P60">Example:<br/><span class="RW_20_Reserved_20_word">subtype</span> URI_Term_Type_Without_Finalize <span class="RW_20_Reserved_20_word">is</span></p><p class="P60">  Term_Type_Without_Finalize</p><p class="P60">   <span class="RW_20_Reserved_20_word">with</span> Dynamic_Predicate =&gt;</p><p class="P60">      Is_URI(URI_Term_Type_Without_Finalize);</p><p class="P22">It is possible that in a future version of the library I will consistently replace controlling arguments with class-wide argument<span class="T70">s</span>.<span class="T65"> This would make it more symmetric, as all tagged arguments would be class-wide and none special controlling one.</span></p><ol><li><h class="P69" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">9.</span><a id="a_9__Dealing_with_callbacks">Dealing with callbacks</a><span class="odfLiEnd"/> </h></li></ol><p class="P10">To deal with C callbacks (<span class="T63">particularly </span>accepting a <span class="PC_20_Program_20_char">void*</span> argument for additional data) in object oriented way, we need a way to convert between C <span class="PC_20_Program_20_char">void</span> pointers and accesses to Ada tagged (even class-wide) objects. <span class="T71">(We pass Ada tagged objects as C “user data” pointers.)</span></p><p class="P11">When we create a callback we need to pass an Ada object as a C pointer and a <span class="PC_20_Program_20_char">Convention=&gt;C</span> subprogram defined by us as the callback. The callback receives the pointer previously passed by us and in the callback code we should (if we want to stay object oriented) convert this pointer into an Ada object access.</p><p class="P13">What we need is some bijective (“back and forth”) mapping between Ada access values and C pointers.</p><p class="P12">At first I was tempted to use <span class="PC_20_Program_20_char"><span class="T45">Ada.</span></span><span class="PC_20_Program_20_char">Unchecked_Conversion</span>. <span class="T45">But (despite GNAT 7.2.0 gives no warning on this) it is not in any way guaranteed to work, because the format of Ada access type and of C pointer are not necessarily the same.</span></p><p class="P36">Now I do conversion this way:</p><p class="P36">I convert <span class="PC_20_Program_20_char">chars_ptr</span> to a <span class="PC_20_Program_20_char">Convention=&gt;C</span> access to <span class="PC_20_Program_20_char">char</span> then this <span class="T64">to </span>access to <span class="PC_20_Program_20_char">System.Address</span> using <span class="PC_20_Program_20_char">System.Address_To_Access_Conversions</span> and then (also by <span class="PC_20_Program_20_char">Address_To_Access_Conversions</span>) address to the required access to a class-wide type.</p><p class="P36">The backward conversion is analogous.</p><p class="P37">The above should work if we understand the words “back and forth” RM13.7.2(5/2) “The To_Pointer and To_Address subprograms convert back and forth between values of types Object_Pointer and Address.” as that the conversion must be bijective. <span class="T46">(I filed a clarification request about meaning of the words “back and forth” to Ada standardization committee.)</span></p><p class="P38">All this is implemented in <span class="PC_20_Program_20_char">RDF.Auxiliary.Convert_Void</span> of my library, but in my opinion this package should be added to Ada standard packages.</p><p class="P44">How to do this in practice? The best way to explain is an example <span class="T68">(for a user-defined I/O Stream which calls our function </span><span class="PC_20_Program_20_char"><span class="T68">Do_Write_Bytes</span></span><span class="T68"> when “write” message is sent to it)</span>:</p><p class="P59"><span class="RW_20_Reserved_20_word">package</span> My_Conv <span class="RW_20_Reserved_20_word">is</span></p><p class="P59">  <span class="RW_20_Reserved_20_word">new</span> RDF.Auxiliary.Convert_Void</p><p class="P59">    (Handled_IOStream_Type_User'Class);</p><p class="P58"><span class="RW_20_Reserved_20_word">function</span> raptor_iostream_write_bytes_impl</p><p class="P58">  (context: chars_ptr; ptr: chars_ptr; size, nmemb: size_t)</p><p class="P58">   <span class="RW_20_Reserved_20_word">return</span> int</p><p class="P59">  <span class="RW_20_Reserved_20_word">with</span> Convention=&gt;C;<br/><span class="RW_20_Reserved_20_word">function</span> raptor_iostream_write_bytes_impl</p><p class="P59">  (context: chars_ptr; ptr: chars_ptr; size, nmemb: size_t)</p><p class="My_20_program">   <span class="RW_20_Reserved_20_word">return</span> int <span class="RW_20_Reserved_20_word">is</span></p><p class="My_20_program"><span class="RW_20_Reserved_20_word">begin</span></p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">declare</span> </p><p class="My_20_program">      Result: <span class="RW_20_Reserved_20_word">constant</span> int := Do_Write_Bytes (My_Conv.To_Access (context).<span class="RW_20_Reserved_20_word">all</span>, ptr, size, nmemb);</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">begin</span></p><p class="My_20_program">      <span class="RW_20_Reserved_20_word">return</span> Result;</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">end</span>;</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">exception</span></p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">when</span> <span class="RW_20_Reserved_20_word">others</span> =&gt;</p><p class="My_20_program">      <span class="RW_20_Reserved_20_word">return</span> -1;</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">end</span>;</p><ol><li><h class="MH_20_Main_20_heading" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">10.</span><a id="a_10__Storage_pools_for_memory_allocation">Storage pools for memory allocation</a><span class="odfLiEnd"/> </h></li></ol><p class="P15">I <span class="T50">tried to</span> define storage pools <span class="T50">for C allocation/deallocation functions such as </span><span class="PC_20_Program_20_char"><span class="T50">raptor_alloc_memory()</span></span><span class="T50"> and </span><span class="PC_20_Program_20_char"><span class="T50">raptor_free_memory()</span></span><span class="T50">, but it appeared to be impossible by the following reason:</span></p><p class="P43"><span class="PC_20_Program_20_char">System.Storage_Pools</span> <span class="T53">receives </span><span class="PC_20_Program_20_char"><span class="T53">Alignment</span></span><span class="T53"> argument which is an integer multiple of the alignment of the allocated type. This alignment may be greater than the alignment </span><span class="PC_20_Program_20_char"><span class="T50">raptor_alloc_memory()</span></span><span class="T50"> warrants (</span><span class="PC_20_Program_20_char"><span class="T50">Dummy_Record’Alignment</span></span><span class="T50">) and so lead to undefined behavior.</span></p><p class="P17">I have sent a proposal to the standardization committee to <span class="T54">make the programmer able to restrict the maximum alignment</span>.</p><p class="P16">Because using allocators appeared to be impossible, I did it <span class="T66">instead </span>this way (for <span class="PC_20_Program_20_char">Locator_Handle</span> which is a pointer to <span class="PC_20_Program_20_char">Locator_Type</span> record):</p><p class="P57"><span class="RW_20_Reserved_20_word">package</span> Locator_Conv <span class="RW_20_Reserved_20_word">is</span></p><p class="P57"><span class="RW_20_Reserved_20_word"> </span> <span class="RW_20_Reserved_20_word">new</span> RDF.Auxiliary.Convert_Void(Locator_Type_Record);</p><p class="My_20_program"> </p><p class="P56"><span class="RW_20_Reserved_20_word">function</span> Copy_Locator (Handle: Locator_Handle)</p><p class="P56">  <span class="RW_20_Reserved_20_word">return</span> Locator_Handle</p><p class="P56"><span class="RW_20_Reserved_20_word">is</span></p><p class="P56">  Size: <span class="RW_20_Reserved_20_word">constant</span> size_t := size_t((Locator_Type'Max_Size_In_Storage_Elements * Storage_Unit + (char'Size-1)) / char'Size);</p><p class="P56">  Result2: <span class="RW_20_Reserved_20_word">constant</span> chars_ptr :=</p><p class="P56">    RDF.Raptor.Memory.raptor_alloc_memory(Size);</p><p class="P56">  Result: <span class="RW_20_Reserved_20_word">constant</span> Locator_Handle :=</p><p class="P56">    Locator_Handle(Locator_Conv.To_Access(Result2));</p><p class="My_20_program">begin</p><p class="My_20_program">  Result.<span class="RW_20_Reserved_20_word">all</span> := Handle.<span class="RW_20_Reserved_20_word">all</span>;</p><p class="My_20_program">  Result.URI := raptor_uri_copy(Handle.URI);</p><p class="My_20_program">  Result.File := RDF.Raptor.Memory.Copy_C_String(Handle.File);</p><p class="My_20_program">  <span class="RW_20_Reserved_20_word">return</span> Result;</p><p class="My_20_program"><span class="RW_20_Reserved_20_word">end</span>;</p><p class="TP_20_Text_20_para">Note that <span class="PC_20_Program_20_char">(Locator_Type'Max_Size_In_Storage_Elements * Storage_Unit + (char'Size-1)) / char'Size</span> is the ceiling of floating point division of  <span class="PC_20_Program_20_char">Locator_Type'Max_Size_In_Storage_Elements * Storage_Unit</span> by <span class="PC_20_Program_20_char">char'Size</span> (but without using floating point). <span class="T67">Using ceiling warrants that the allocated space is at least as big as required space.</span></p><p class="TP_20_Text_20_para">Here I allocate with  <span class="PC_20_Program_20_char">raptor_alloc_memory()</span> function the amount of memory which is max size needed <span class="T52">(apparently not to overwrite nearby memory) </span>for a record pointed by <span class="PC_20_Program_20_char">Locator_Type</span> (<span class="T51">ARM specifies this max size only for memory returned by an allocator, but I am pretty sure that in any reasonable implementation of Ada the same amount of memory will work well if it is allocated by </span><span class="PC_20_Program_20_char">raptor_alloc_memory()</span> function <span class="T51">instead and the nearby memory thus won’t be overwritten).</span></p><ol><li><h class="P63" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">11.</span><a id="a_11__More_little_things">More little things</a><span class="odfLiEnd"/> </h></li></ol><p class="P18"><span class="T8">A</span><span class="T2">da standard misses a function converting a C string (with possible NULs) described by a </span><span class="PC_20_Program_20_char"><span class="T2">chars_ptr</span></span><span class="T2"> and and its length in characters into an Ada String.</span></p><p class="P18"><span class="T2">I define function </span><span class="PC_20_Program_20_char"><span class="T2">Value_With_Possible_NULs</span></span><span class="T2"> which does this in terms of </span><span class="PC_20_Program_20_char"><span class="T2">Interfaces.C.Pointers</span></span><span class="T2">. Note that the pointer defined in suitably instantiated </span><span class="PC_20_Program_20_char"><span class="T2">Interfaces.C.Pointers</span></span><span class="T2"> is correctly converted from/to </span><span class="PC_20_Program_20_char"><span class="T2">chars_ptr</span></span><span class="T2"> with </span><span class="PC_20_Program_20_char"><span class="T10">Ada.</span></span><span class="PC_20_Program_20_char"><span class="T9">Unchecked_Conversion</span></span><span class="T2">.</span></p><p class="P19"><span class="T2">The Ada standard </span><span class="PC_20_Program_20_char"><span class="T2">To_C</span></span><span class="T2"> with </span><span class="PC_20_Program_20_char"><span class="T2">Trim_Nul=&gt;False</span></span><span class="T2"> is broken: RM B.3(51) “If Append_Nul is False and Item'Length is 0, then To_C propagates Constraint_Error.” </span><span class="T12">Said in another way the Standard means</span><span class="T11">: “This does not work with empty strings.”</span><span class="T2"> So I wrote a wrapper </span><span class="PC_20_Program_20_char"><span class="T2">My_To_C_Without_Nul</span></span><span class="T2"> around it.</span></p><p class="P20"><span class="T2">I would write a lot more advice how to write Ada binding</span><span class="T13">s</span><span class="T2"> for a C library, but you can just follow my source, which can serve as an example.</span></p><p class="P24"><span class="T2">I “encode” values of C strings (which can be NULL) as an Ada indefinite holder holding a </span><span class="PC_20_Program_20_char"><span class="T2">String</span></span><span class="T2">. </span><span class="T14">If the string is NULL, the holder is empty. However often it is enough to transform an empty Ada string into NULL C string </span><span class="T15">(this can work only if we don’t differentiate between empty and null strings)</span><span class="T14">.</span></p><ol><li><h class="P62" style="margin-left:0cm;"><span class="Numbering_20_Symbols" style="display:block;float:left;min-width:0.4991cm;">12.</span><a id="a_12__References">References</a><span class="odfLiEnd"/> </h></li></ol><ol><li><p class="P71" style="margin-left:0cm;"><span class="WW8Num1z0" style="display:block;float:left;min-width:0.635cm;">[1]</span><a id="__RefNumPara__6535_3978438061"/><span class="T43">Bootstrapping RDF applications with Redland. David Beckett, </span><a href="https://www.dajobe.org/papers/xtech2005/" class="Internet_20_link"><span class="T43">https://www.dajobe.org/papers/xtech2005/</span></a><span class="T43"> </span><span class="odfLiEnd"/> </p></li><li><p class="P71" style="margin-left:0cm;"><span class="WW8Num1z0" style="display:block;float:left;min-width:0.635cm;">[2]</span><a id="__RefNumPara__6410_3978438061"/><span class="T29">ISO/IEC 9899:2011 section 6.2.5 paragraph 28</span>.<span class="odfLiEnd"/> </p></li><li><p class="P71" style="margin-left:0cm;"><span class="WW8Num1z0" style="display:block;float:left;min-width:0.635cm;">[3]</span><a id="__RefNumPara__6537_3978438061"/>Resource Description Framework (RDF). RDF Working Group, <a href="https://www.w3.org/RDF/" class="Internet_20_link">https://www.w3.org/RDF/</a><span class="odfLiEnd"/> </p></li><li><p class="P71" style="margin-left:0cm;"><span class="WW8Num1z0" style="display:block;float:left;min-width:0.635cm;">[4]</span><a id="__RefNumPara__6380_3978438061"/>The Design and Implementation of the Redland RDF Application Framework. David Beckett, <span class="T43">2001, </span><a href="http://www10.org/cdrom/papers/490/" class="Internet_20_link"><span class="T43">http://www10.org/cdrom/papers/490/</span></a><span class="odfLiEnd"/> </p></li></ol></div></body></html>